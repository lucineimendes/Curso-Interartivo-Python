[
    {
        "id": "ex-patterns-singleton-2",
        "lesson_id": "poo-avancado-patterns",
        "title": "Singleton com Atributo de Configuração",
        "description": "Estenda a classe `Configuracao` (Singleton) para permitir definir e obter um atributo específico, como `API_KEY`. Garanta que o valor persista entre diferentes 'instâncias'.",
        "difficulty": "Médio",
        "order": 1,
        "instructions": "Modifique a classe `Configuracao` para ter um método `get_api_key()` e `set_api_key(key)`. Teste criando duas 'instâncias', definindo a chave em uma e obtendo na outra.",
        "initial_code": "class Configuracao:\n    _instance = None\n\n    def __new__(cls, *args, **kwargs):\n        if not cls._instance:\n            cls._instance = super().__new__(cls, *args, **kwargs)\n            cls._instance._initialized = False # Use uma flag para inicialização\n        return cls._instance\n\n    def __init__(self):\n        if not self._initialized:\n            self._api_key = None\n            self._initialized = True\n            print(\"Singleton de Configuração inicializado.\")\n\n    # Adicione os métodos get_api_key e set_api_key aqui\n\n# Teste\n# config1 = Configuracao()\n# config1.set_api_key(\"sua_chave_secreta\")\n# config2 = Configuracao()\n# print(f\"API Key de config2: {config2.get_api_key()}\")\n# print(f\"config1 é a mesma instância que config2: {config1 is config2}\")",
        "solution_code": "class Configuracao:\n    _instance = None\n\n    def __new__(cls, *args, **kwargs):\n        if not cls._instance:\n            cls._instance = super().__new__(cls, *args, **kwargs)\n            cls._instance._initialized = False\n        return cls._instance\n\n    def __init__(self):\n        if not self._initialized:\n            self._api_key = None\n            self._initialized = True\n            print(\"Singleton de Configuração inicializado.\")\n\n    def get_api_key(self):\n        return self._api_key\n\n    def set_api_key(self, key):\n        self._api_key = key\n\n# Teste\nconfig1 = Configuracao()\nconfig1.set_api_key(\"sua_chave_secreta\")\nconfig2 = Configuracao()\nprint(f\"API Key de config2: {config2.get_api_key()}\")\nprint(f\"config1 é a mesma instância que config2: {config1 is config2}\")",
        "test_code": "assert \"Singleton de Configuração inicializado.\" in output and \"API Key de config2: sua_chave_secreta\" in output and \"config1 é a mesma instância que config2: True\" in output",
        "level": "avançado"
    },
    {
        "id": "ex-patterns-factory-method-1",
        "lesson_id": "poo-avancado-patterns",
        "title": "Factory Method: Criando Formas",
        "description": "Crie uma classe base abstrata `Forma` com um método abstrato `desenhar()`. Crie subclasses `Circulo` e `Quadrado` que implementam `desenhar()`. Implemente uma classe `FabricaDeFormas` com um método de classe `criar_forma(tipo)` que retorna uma instância da forma correta (`Circulo` ou `Quadrado`) com base no tipo fornecido ('circulo' ou 'quadrado').",
        "difficulty": "Difícil",
        "order": 2,
        "instructions": "Use `abc` para a classe base abstrata. A `FabricaDeFormas.criar_forma` deve usar condicionais para decidir qual classe instanciar e retornar. Teste criando formas usando a fábrica.",
        "initial_code": "from abc import ABC, abstractmethod\n\nclass Forma(ABC):\n    @abstractmethod\n    def desenhar(self):\n        pass\n\nclass Circulo(Forma):\n    def desenhar(self):\n        print(\"Desenhando um Círculo.\")\n\nclass Quadrado(Forma):\n    def desenhar(self):\n        print(\"Desenhando um Quadrado.\")\n\nclass FabricaDeFormas:\n    @classmethod\n    def criar_forma(cls, tipo):\n        # Implemente a lógica para retornar Circulo ou Quadrado\n        # com base no valor de 'tipo'\n        pass\n\n# Teste\n# forma1 = FabricaDeFormas.criar_forma('circulo')\n# forma1.desenhar()\n# forma2 = FabricaDeFormas.criar_forma('quadrado')\n# forma2.desenhar()",
        "solution_code": "from abc import ABC, abstractmethod\n\nclass Forma(ABC):\n    @abstractmethod\n    def desenhar(self):\n        pass\n\nclass Circulo(Forma):\n    def desenhar(self):\n        print(\"Desenhando um Círculo.\")\n\nclass Quadrado(Forma):\n    def desenhar(self):\n        print(\"Desenhando um Quadrado.\")\n\nclass FabricaDeFormas:\n    @classmethod\n    def criar_forma(cls, tipo):\n        if tipo.lower() == 'circulo':\n            return Circulo()\n        elif tipo.lower() == 'quadrado':\n            return Quadrado()\n        else:\n            raise ValueError(f\"Tipo de forma desconhecido: {tipo}\")\n\n# Teste\nforma1 = FabricaDeFormas.criar_forma('circulo')\nforma1.desenhar()\nforma2 = FabricaDeFormas.criar_forma('quadrado')\nforma2.desenhar()",
        "test_code": "assert \"Desenhando um Círculo.\" in output and \"Desenhando um Quadrado.\" in output",
        "level": "avançado"
    },
    {
        "id": "ex-patterns-adapter-1",
        "lesson_id": "poo-avancado-patterns",
        "title": "Adapter: Integrando Sistemas de Log",
        "description": "Suponha que você tem um sistema de log antigo (`LogSistemaAntigo`) com um método `registrar_evento(mensagem)`. Você quer usar este sistema, mas seu código espera uma interface de log moderna com um método `log(mensagem)`. Crie um Adapter (`LogAdapter`) que adapte a interface antiga para a nova.",
        "difficulty": "Médio",
        "order": 3,
        "instructions": "Crie a classe `LogSistemaAntigo`. Crie a classe `LogAdapter` que receba uma instância de `LogSistemaAntigo` no construtor e implemente o método `log(mensagem)` chamando o método `registrar_evento` da instância antiga.",
        "initial_code": "class LogSistemaAntigo:\n    def registrar_evento(self, mensagem):\n        print(f\"[LOG ANTIGO] Evento registrado: {mensagem}\")\n\n# Interface esperada pelo código moderno\n# class InterfaceLogModerna:\n#     def log(self, mensagem):\n#         pass # Método a ser implementado pelo adapter\n\nclass LogAdapter:\n    def __init__(self, sistema_antigo):\n        # Armazene a instância do sistema antigo\n        pass\n\n    def log(self, mensagem):\n        # Chame o método registrar_evento do sistema antigo\n        pass\n\n# Teste\n# sistema_antigo = LogSistemaAntigo()\n# adapter = LogAdapter(sistema_antigo)\n# adapter.log(\"Esta mensagem usa o adapter.\")",
        "solution_code": "class LogSistemaAntigo:\n    def registrar_evento(self, mensagem):\n        print(f\"[LOG ANTIGO] Evento registrado: {mensagem}\")\n\n# Interface esperada pelo código moderno (conceitual para este exercício)\n# class InterfaceLogModerna:\n#     def log(self, mensagem):\n#         pass\n\nclass LogAdapter:\n    def __init__(self, sistema_antigo):\n        self._sistema_antigo = sistema_antigo\n\n    def log(self, mensagem):\n        self._sistema_antigo.registrar_evento(mensagem)\n\n# Teste\nsistema_antigo = LogSistemaAntigo()\nadapter = LogAdapter(sistema_antigo)\nadapter.log(\"Esta mensagem usa o adapter.\")",
        "test_code": "assert \"[LOG ANTIGO] Evento registrado: Esta mensagem usa o adapter.\" in output",
        "level": "avançado"
    },
    {
        "id": "ex-patterns-decorator-2",
        "lesson_id": "poo-avancado-patterns",
        "title": "Decorador para Medir Tempo de Execução",
        "description": "Crie um decorador `@medir_tempo` que possa ser aplicado a qualquer função. Este decorador deve medir quanto tempo a função leva para executar e imprimir essa informação antes de retornar o resultado da função original.",
        "difficulty": "Difícil",
        "order": 4,
        "instructions": "Use o módulo `time`. O decorador deve envolver a função original, registrar o tempo antes e depois da execução, calcular a diferença e imprimir. Use `functools.wraps`.",
        "initial_code": "import time\nimport functools\n\ndef medir_tempo(func):\n    @functools.wraps(func)\n    def wrapper(*args, **kwargs):\n        # Registrar tempo de início\n        # Chamar a função original e obter o resultado\n        # Registrar tempo de fim\n        # Calcular a duração\n        # Imprimir a duração (ex: 'Função [nome_funcao] executada em X.YYY segundos.')\n        # Retornar o resultado da função original\n        pass\n    return wrapper\n\n# Aplique o decorador à função abaixo\n# @medir_tempo\n# def funcao_lenta():\n#     \"\"\"Uma função que simula trabalho.\"\"\"\n#     time.sleep(1)\n#     print(\"Função lenta terminou.\")\n#     return \"feito\"\n\n# resultado = funcao_lenta()\n# print(f\"Resultado: {resultado}\")",
        "solution_code": "import time\nimport functools\n\ndef medir_tempo(func):\n    @functools.wraps(func)\n    def wrapper(*args, **kwargs):\n        inicio = time.time()\n        resultado = func(*args, **kwargs)\n        fim = time.time()\n        duracao = fim - inicio\n        print(f\"Função {func.__name__} executada em {duracao:.3f} segundos.\")\n        return resultado\n    return wrapper\n\n@medir_tempo\ndef funcao_lenta():\n    \"\"\"Uma função que simula trabalho.\"\"\"\n    time.sleep(0.1) # Usar um tempo menor para o teste ser rápido\n    print(\"Função lenta terminou.\")\n    return \"feito\"\n\nresultado = funcao_lenta()\nprint(f\"Resultado: {resultado}\")",
        "test_code": "assert \"Função lenta terminou.\" in output and \"Função funcao_lenta executada em\" in output and \"segundos.\" in output and \"Resultado: feito\" in output",
        "level": "avançado"
    },
    {
        "id": "ex-patterns-observer-1",
        "lesson_id": "poo-avancado-patterns",
        "title": "Observer: Notificando Assinantes",
        "description": "Implemente o padrão Observer. Crie uma classe `Subject` (Observável) que mantenha uma lista de `Observers` (Observadores). O `Subject` deve ter métodos para anexar (`attach`), desanexar (`detach`) e notificar (`notify`) seus observadores. Crie uma classe `Observer` com um método `update(mensagem)` que é chamado pelo `Subject` durante a notificação.",
        "difficulty": "Difícil",
        "order": 5,
        "instructions": "A classe `Subject` precisa de uma lista para os observadores. O método `notify` deve iterar sobre essa lista e chamar o método `update` de cada observador. A classe `Observer` é simples, apenas imprime a mensagem recebida no `update`.",
        "initial_code": "class Subject:\n    def __init__(self):\n        self._observers = []\n\n    def attach(self, observer):\n        # Adicione o observer à lista se ainda não estiver lá\n        pass\n\n    def detach(self, observer):\n        # Remova o observer da lista se estiver lá\n        pass\n\n    def notify(self, mensagem):\n        print(f\"Subject: Notificando observadores com '{mensagem}'\")\n        # Itere sobre os observers e chame o método update de cada um\n        pass\n\nclass Observer:\n    def __init__(self, nome):\n        self.nome = nome\n\n    def update(self, mensagem):\n        # Imprima que o observer recebeu a mensagem\n        print(f\"Observer {self.nome}: Recebi a mensagem -> {mensagem}\")\n\n# Teste\n# subject = Subject()\n# observer_a = Observer(\"A\")\n# observer_b = Observer(\"B\")\n\n# subject.attach(observer_a)\n# subject.attach(observer_b)\n\n# subject.notify(\"Primeira Notificação\")\n\n# subject.detach(observer_a)\n\n# subject.notify(\"Segunda Notificação\")",
        "solution_code": "class Subject:\n    def __init__(self):\n        self._observers = []\n\n    def attach(self, observer):\n        if observer not in self._observers:\n            self._observers.append(observer)\n            print(f\"Subject: Observer {observer.nome} anexado.\")\n\n    def detach(self, observer):\n        try:\n            self._observers.remove(observer)\n            print(f\"Subject: Observer {observer.nome} desanexado.\")\n        except ValueError:\n            print(f\"Subject: Observer {observer.nome} não encontrado para desanexar.\")\n\n    def notify(self, mensagem):\n        print(f\"Subject: Notificando observadores com '{mensagem}'\")\n        for observer in self._observers:\n            observer.update(mensagem)\n\nclass Observer:\n    def __init__(self, nome):\n        self.nome = nome\n\n    def update(self, mensagem):\n        print(f\"Observer {self.nome}: Recebi a mensagem -> {mensagem}\")\n\n# Teste\nsubject = Subject()\nobserver_a = Observer(\"A\")\nobserver_b = Observer(\"B\")\n\nsubject.attach(observer_a)\nsubject.attach(observer_b)\n\nsubject.notify(\"Primeira Notificação\")\n\nsubject.detach(observer_a)\n\nsubject.notify(\"Segunda Notificação\")",
        "test_code": "assert \"Subject: Observer A anexado.\" in output and \"Subject: Observer B anexado.\" in output and \"Subject: Notificando observadores com 'Primeira Notificação'\" in output and \"Observer A: Recebi a mensagem -> Primeira Notificação\" in output and \"Observer B: Recebi a mensagem -> Primeira Notificação\" in output and \"Subject: Observer A desanexado.\" in output and \"Subject: Notificando observadores com 'Segunda Notificação'\" in output and \"Observer A: Recebi a mensagem -> Segunda Notificação\" not in output and \"Observer B: Recebi a mensagem -> Segunda Notificação\" in output",
        "level": "avançado"
    },
    {
        "id": "ex-patterns-strategy-1",
        "lesson_id": "poo-avancado-patterns",
        "title": "Strategy: Diferentes Formas de Pagamento",
        "description": "Implemente o padrão Strategy. Crie uma classe `ContextoPagamento` que use uma 'estratégia' de pagamento. Crie classes de estratégia (`EstrategiaPagamentoCredito`, `EstrategiaPagamentoPaypal`) com um método comum `processar_pagamento(valor)`. O `ContextoPagamento` deve receber uma estratégia e delegar a ela o processamento.",
        "difficulty": "Difícil",
        "order": 6,
        "instructions": "Defina uma classe base (pode ser abstrata ou não, dependendo da necessidade) para as estratégias. As classes de estratégia devem implementar o método `processar_pagamento`. A classe `ContextoPagamento` deve ter um atributo para a estratégia atual e um método que chama `processar_pagamento` dessa estratégia.",
        "initial_code": "class EstrategiaPagamentoCredito:\n    def processar_pagamento(self, valor):\n        # Implemente a lógica de pagamento com cartão\n        print(f\"Processando pagamento de R${valor:.2f} com Cartão de Crédito.\")\n\nclass EstrategiaPagamentoPaypal:\n    def processar_pagamento(self, valor):\n        # Implemente a lógica de pagamento com PayPal\n        print(f\"Processando pagamento de R${valor:.2f} com PayPal.\")\n\nclass ContextoPagamento:\n    def __init__(self, estrategia):\n        # Armazene a estratégia de pagamento\n        pass\n\n    def executar_pagamento(self, valor):\n        # Chame o método processar_pagamento da estratégia armazenada\n        pass\n\n# Teste\n# pagamento_credito = ContextoPagamento(EstrategiaPagamentoCredito())\n# pagamento_credito.executar_pagamento(150.75)\n\n# pagamento_paypal = ContextoPagamento(EstrategiaPagamentoPaypal())\n# pagamento_paypal.executar_pagamento(50.00)",
        "solution_code": "class EstrategiaPagamentoCredito:\n    def processar_pagamento(self, valor):\n        print(f\"Processando pagamento de R${valor:.2f} com Cartão de Crédito.\")\n        # Lógica real de processamento... (simulado)\n        return True # Sucesso\n\nclass EstrategiaPagamentoPaypal:\n    def processar_pagamento(self, valor):\n        print(f\"Processando pagamento de R${valor:.2f} com PayPal.\")\n        # Lógica real de processamento... (simulado)\n        return True # Sucesso\n\n# Poderia ter uma classe base abstrata EstrategiaPagamento(ABC) com @abstractmethod processar_pagamento\n\nclass ContextoPagamento:\n    def __init__(self, estrategia):\n        # A estratégia deve ser uma instância de uma classe de estratégia\n        self._estratregia = estrategia\n\n    def executar_pagamento(self, valor):\n        print(\"Contexto: Executando pagamento...\")\n        resultado = self._estratregia.processar_pagamento(valor)\n        if resultado:\n            print(\"Contexto: Pagamento concluído com sucesso.\")\n        else:\n            print(\"Contexto: Falha no pagamento.\")\n        return resultado\n\n# Teste\npagamento_credito = ContextoPagamento(EstrategiaPagamentoCredito())\npagamento_credito.executar_pagamento(150.75)\n\npagamento_paypal = ContextoPagamento(EstrategiaPagamentoPaypal())\npagamento_paypal.executar_pagamento(50.00)",
        "test_code": "assert \"Processando pagamento de R$150.75 com Cartão de Crédito.\" in output and \"Contexto: Pagamento concluído com sucesso.\" in output and \"Processando pagamento de R$50.00 com PayPal.\" in output",
        "level": "avançado"
    },
    {
        "id": "ex-metaclasses-simples-1",
        "lesson_id": "poo-avancado-metaclasses-decorators",
        "title": "Metaclasse Básica: Adicionando um Atributo",
        "description": "Crie uma metaclasse simples chamada `MinhaMeta` que, ao criar uma classe, adicione automaticamente um atributo de classe chamado `criado_por` com o valor `'MinhaMeta'` à classe recém-criada. Defina uma classe `MinhaClasse` que use `MinhaMeta` como sua metaclasse e imprima o valor do atributo `criado_por`.",
        "difficulty": "Médio",
        "order": 1,
        "instructions": "Defina a classe `MinhaMeta` herdando de `type`. Implemente o método `__new__` na metaclasse para adicionar o atributo `criado_por` ao `namespace` da classe antes de criá-la. Defina `MinhaClasse` com `metaclass=MinhaMeta`. Imprima `MinhaClasse.criado_por`.",
        "initial_code": "# Defina a metaclasse MinhaMeta aqui\n# class MinhaMeta(type):\n#     def __new__(cls, name, bases, dct):\n#         # Modifique o dicionário 'dct' antes de chamar o super().__new__\n#         # return super().__new__(...)\n#         pass\n\n# Defina a classe MinhaClasse usando a metaclasse\n# class MinhaClasse(metaclass=MinhaMeta):\n#     pass\n\n# Imprima o atributo adicionado pela metaclasse\n# print(MinhaClasse.criado_por)",
        "solution_code": "class MinhaMeta(type):\n    def __new__(cls, name, bases, dct):\n        # Adiciona o atributo 'criado_por' ao dicionário da classe\n        dct['criado_por'] = 'MinhaMeta'\n        # Chama o __new__ da metaclasse base (type) para criar a classe\n        return super().__new__(cls, name, bases, dct)\n\n# Define a classe MinhaClasse usando a metaclasse\nclass MinhaClasse(metaclass=MinhaMeta):\n    pass\n\n# Imprime o atributo adicionado pela metaclasse\nprint(MinhaClasse.criado_por)",
        "test_code": "assert MinhaClasse.criado_por == 'MinhaMeta' and 'MinhaMeta' in output",
        "level": "avançado"
    },
    {
        "id": "ex-metaclasses-validacao-1",
        "lesson_id": "poo-avancado-metaclasses-decorators",
        "title": "Metaclasse para Validar Nomes de Atributos",
        "description": "Crie uma metaclasse `ValidarAtributosMeta` que verifique se nenhuma classe que a utiliza possui atributos (exceto métodos) cujos nomes comecem com um underscore simples (`_`). Se encontrar um atributo assim, deve levantar um `TypeError` durante a criação da classe.",
        "difficulty": "Difícil",
        "order": 2,
        "instructions": "Na metaclasse `ValidarAtributosMeta`, no método `__new__`, itere sobre os itens do dicionário `dct` (que contém os atributos e métodos da classe). Para cada item que não seja um método (`callable`), verifique se o nome começa com `_` e não com `__`. Se a condição for atendida, levante o `TypeError` com uma mensagem explicativa.",
        "initial_code": "class ValidarAtributosMeta(type):\n    def __new__(cls, name, bases, dct):\n        # Itere sobre dct para verificar nomes de atributos\n        # Se encontrar um atributo inválido, levante TypeError\n        # return super().__new__(...)\n        pass\n\n# Classe de teste (deve funcionar)\nclass ClasseValida(metaclass=ValidarAtributosMeta):\n    atributo_publico = 10\n    _atributo_privado_convencao = 20 # Este deve ser permitido (underscore duplo)\n    __atributo_realmente_privado = 30\n    def um_metodo(self):\n        pass\n\nprint(\"ClasseValida criada com sucesso.\")\n\n# Classe de teste (deve falhar com TypeError)\n# class ClasseInvalida(metaclass=ValidarAtributosMeta):\n#     _atributo_invalido = 5\n\n# print(\"Tentando criar ClasseInvalida...\")\n# try:\n#     class ClasseInvalida(metaclass=ValidarAtributosMeta):\n#         _atributo_invalido = 5\n# except TypeError as e:\n#     print(f\"Erro esperado: {e}\")",
        "solution_code": "class ValidarAtributosMeta(type):\n    def __new__(cls, name, bases, dct):\n        for attr_name, attr_value in dct.items():\n            # Verifica se o nome começa com '_' mas não com '__'\n            # e se não é um método (callable)\n            if attr_name.startswith('_') and not attr_name.startswith('__') and not callable(attr_value):\n                raise TypeError(f\"Atributo '{attr_name}' na classe '{name}' não deve começar com um único underscore.\")\n\n        return super().__new__(cls, name, bases, dct)\n\n# Classe de teste (deve funcionar)\nclass ClasseValida(metaclass=ValidarAtributosMeta):\n    atributo_publico = 10\n    __atributo_realmente_privado = 30 # Underscore duplo é permitido\n    def _metodo_privado_convencao(self):\n        pass\n\nprint(\"ClasseValida criada com sucesso.\")\n\n# Classe de teste (deve falhar com TypeError)\nprint(\"\\nTentando criar ClasseInvalida...\")\ntry:\n    class ClasseInvalida(metaclass=ValidarAtributosMeta):\n        _atributo_invalido = 5\n    print(\"ERRO: ClasseInvalida criada, mas deveria ter falhado.\")\nexcept TypeError as e:\n    print(f\"Erro esperado ao criar ClasseInvalida: {e}\")",
        "test_code": "assert \"ClasseValida criada com sucesso.\" in output and \"Erro esperado ao criar ClasseInvalida: Atributo '_atributo_invalido' na classe 'ClasseInvalida' não deve começar com um único underscore.\" in output",
        "level": "avançado"
    },
    {
        "id": "ex-decorator-args-log-2",
        "lesson_id": "poo-avancado-metaclasses-decorators",
        "title": "Decorador com Argumentos: Log de Entrada/Saída",
        "description": "Crie um decorador `@log_io(prefixo)` que aceite um argumento `prefixo`. O decorador deve imprimir uma mensagem formatada usando o `prefixo` antes da chamada da função (mostrando os argumentos passados) e depois da chamada (mostrando o resultado retornado). Use `functools.wraps`.",
        "difficulty": "Difícil",
        "order": 3,
        "instructions": "Defina a estrutura aninhada do decorador: uma função externa `log_io` que recebe `prefixo`, uma função intermediária `decorator` que recebe `func`, e a função interna `wrapper` que recebe `*args` e `**kwargs`. Dentro de `wrapper`, imprima a mensagem de entrada (incluindo `prefixo`, nome da função, args/kwargs), chame a função original, imprima a mensagem de saída (incluindo `prefixo`, nome da função, resultado) e retorne o resultado. Use `functools.wraps` no `wrapper`.",
        "initial_code": "import functools\n\ndef log_io(prefixo):\n    def decorator(func):\n        @functools.wraps(func)\n        def wrapper(*args, **kwargs):\n            # Imprimir mensagem de entrada com prefixo, nome da função, args e kwargs\n            # Chamar a função original\n            # Imprimir mensagem de saída com prefixo, nome da função e resultado\n            # Retornar o resultado\n            pass\n        return wrapper\n    return decorator\n\n# Aplique o decorador com um prefixo\n# @log_io(prefixo=\"[DEBUG]\")\n# def multiplicar(a, b):\n#     print(\"Calculando multiplicação...\")\n#     return a * b\n\n# resultado = multiplicar(4, 5)\n# print(f\"Resultado final: {resultado}\")",
        "solution_code": "import functools\n\ndef log_io(prefixo):\n    def decorator(func):\n        @functools.wraps(func)\n        def wrapper(*args, **kwargs):\n            # Formata os argumentos para impressão\n            args_str = ', '.join(map(repr, args))\n            kwargs_str = ', '.join(f'{k}={v!r}' for k, v in kwargs.items())\n            all_args_str = ', '.join(filter(None, [args_str, kwargs_str]))\n\n            print(f\"{prefixo} Entrando em '{func.__name__}' com args=({all_args_str})\")\n\n            try:\n                resultado = func(*args, **kwargs)\n                print(f\"{prefixo} Saindo de '{func.__name__}' com resultado={resultado!r}\")\n                return resultado\n            except Exception as e:\n                print(f\"{prefixo} Exceção em '{func.__name__}': {e!r}\")\n                raise # Re-levanta a exceção\n\n        return wrapper\n    return decorator\n\n# Aplique o decorador com um prefixo\n@log_io(prefixo=\"[INFO]\")\ndef somar(a, b):\n    print(\"Executando soma...\")\n    return a + b\n\n@log_io(prefixo=\"[DEBUG]\")\ndef dividir(a, b):\n    print(\"Executando divisão...\")\n    return a / b\n\nresultado_soma = somar(10, b=5)\nprint(f\"Resultado final da soma: {resultado_soma}\")\n\nprint(\"\\nTentando divisão por zero...\")\ntry:\n    resultado_div = dividir(10, 0)\n    print(f\"Resultado final da divisão: {resultado_div}\")\nexcept Exception as e:\n    print(\"Capturada no código principal.\")",
        "test_code": "assert \"[INFO] Entrando em 'somar' com args=(10, b=5)\" in output and \"Executando soma...\" in output and \"[INFO] Saindo de 'somar' com resultado=15\" in output and \"Resultado final da soma: 15\" in output and \"[DEBUG] Entrando em 'dividir' com args=(10, b=0)\" in output and \"Executando divisão...\" in output and \"[DEBUG] Exceção em 'dividir': ZeroDivisionError('division by zero')\" in output and \"Capturada no código principal.\" in output",
        "level": "avançado"
    },
    {
        "id": "ex-decorator-classe-registro-1",
        "lesson_id": "poo-avancado-metaclasses-decorators",
        "title": "Decorador de Classe: Registro Automático",
        "description": "Crie um decorador de classe `@registrar_classe` que registre automaticamente a classe decorada em uma lista global ou de módulo. Após definir algumas classes decoradas, imprima a lista de classes registradas.",
        "difficulty": "Difícil",
        "order": 4,
        "instructions": "Defina uma lista global (ex: `REGISTRO_CLASSES = []`). Crie a função `registrar_classe` que recebe a classe (`cls`) como argumento (pois é um decorador de classe). Dentro dela, adicione a classe à lista global e retorne a classe original (decoradores de classe geralmente retornam a própria classe modificada ou a original). Decore algumas classes simples com `@registrar_classe` e depois imprima o conteúdo de `REGISTRO_CLASSES`.",
        "initial_code": "# Lista global para registro\nREGISTRO_CLASSES = []\n\n# Defina o decorador de classe @registrar_classe aqui\n# def registrar_classe(cls):\n#     # Adicione 'cls' à lista REGISTRO_CLASSES\n#     # print(f\"Classe {cls.__name__} registrada.\") # Opcional para verificação\n#     # Retorne a classe original\n#     pass\n\n# Decore algumas classes\n# @registrar_classe\n# class Servico:\n#     pass\n\n# @registrar_classe\n# class Repositorio:\n#     pass\n\n# Imprima a lista de classes registradas\n# print(\"Classes registradas:\")\n# for cls in REGISTRO_CLASSES:\n#     print(cls.__name__)",
        "solution_code": "# Lista global para registro\nREGISTRO_CLASSES = []\n\n# Defina o decorador de classe @registrar_classe aqui\ndef registrar_classe(cls):\n    REGISTRO_CLASSES.append(cls)\n    print(f\"Classe {cls.__name__} registrada.\")\n    return cls # Retorna a classe original\n\n# Decore algumas classes\n@registrar_classe\nclass Servico:\n    pass\n\n@registrar_classe\nclass Repositorio:\n    pass\n\n# Imprima a lista de classes registradas\nprint(\"\\nClasses registradas:\")\nfor cls in REGISTRO_CLASSES:\n    print(cls.__name__)",
        "test_code": "assert \"Classe Servico registrada.\" in output and \"Classe Repositorio registrada.\" in output and \"Classes registradas:\" in output and \"Servico\" in output.split('\\n') and \"Repositorio\" in output.split('\\n')",
        "level": "avançado"
    },
    {
        "id": "ex-functools-wraps-1",
        "lesson_id": "poo-avancado-metaclasses-decorators",
        "title": "Preservando Metadados com functools.wraps",
        "description": "Crie um decorador simples (sem argumentos) que não use `functools.wraps`. Decore uma função com docstring e nome. Imprima o nome (`__name__`) e a docstring (`__doc__`) da função decorada. Em seguida, modifique o decorador para usar `functools.wraps` e observe a diferença na saída do nome e docstring.",
        "difficulty": "Médio",
        "order": 5,
        "instructions": "Primeiro, crie um decorador `meu_decorador_sem_wraps` que apenas envolva a função. Decore uma função `minha_funcao_original` e imprima seus metadados. Depois, crie `meu_decorador_com_wraps` usando `@functools.wraps(func)` no `wrapper`. Decore a mesma função ou outra e imprima os metadados novamente para comparar.",
        "initial_code": "import functools\n\n# Decorador SEM functools.wraps\ndef meu_decorador_sem_wraps(func):\n    def wrapper(*args, **kwargs):\n        print(\"Wrapper sem wraps antes...\")\n        resultado = func(*args, **kwargs)\n        print(\"Wrapper sem wraps depois...\")\n        return resultado\n    return wrapper\n\n# Decorador COM functools.wraps\ndef meu_decorador_com_wraps(func):\n    # Adicione @functools.wraps(func) aqui\n    def wrapper(*args, **kwargs):\n        print(\"Wrapper com wraps antes...\")\n        resultado = func(*args, **kwargs)\n        print(\"Wrapper com wraps depois...\")\n        return resultado\n    return wrapper\n\n# Função original para ser decorada\n# @meu_decorador_sem_wraps\n# def funcao_teste_sem():\n#     \"\"\"Docstring da função original (sem wraps).\"\"\"\n#     print(\"Executando funcao_teste_sem\")\n#     return \"resultado_sem\"\n\n# print(\"--- Teste SEM wraps ---\")\n# funcao_teste_sem()\n# print(f\"Nome: {funcao_teste_sem.__name__}\")\n# print(f\"Docstring: {funcao_teste_sem.__doc__}\")\n\n# Função original (ou a mesma, decorada de forma diferente)\n# @meu_decorador_com_wraps\n# def funcao_teste_com():\n#     \"\"\"Docstring da função original (com wraps).\"\"\"\n#     print(\"Executando funcao_teste_com\")\n#     return \"resultado_com\"\n\n# print(\"\\n--- Teste COM wraps ---\")\n# funcao_teste_com()\n# print(f\"Nome: {funcao_teste_com.__name__}\")\n# print(f\"Docstring: {funcao_teste_com.__doc__}\")",
        "solution_code": "import functools\n\n# Decorador SEM functools.wraps\ndef meu_decorador_sem_wraps(func):\n    def wrapper(*args, **kwargs):\n        print(\"Wrapper sem wraps antes...\")\n        resultado = func(*args, **kwargs)\n        print(\"Wrapper sem wraps depois...\")\n        return resultado\n    return wrapper\n\n# Decorador COM functools.wraps\ndef meu_decorador_com_wraps(func):\n    @functools.wraps(func) # Usa functools.wraps\n    def wrapper(*args, **kwargs):\n        print(\"Wrapper com wraps antes...\")\n        resultado = func(*args, **kwargs)\n        print(\"Wrapper com wraps depois...\")\n        return resultado\n    return wrapper\n\n# Função original para ser decorada\n@meu_decorador_sem_wraps\ndef funcao_teste_sem():\n    \"\"\"Docstring da função original (sem wraps).\"\"\"\n    print(\"Executando funcao_teste_sem\")\n    return \"resultado_sem\"\n\nprint(\"--- Teste SEM wraps ---\")\nfuncao_teste_sem()\nprint(f\"Nome: {funcao_teste_sem.__name__}\")\nprint(f\"Docstring: {funcao_teste_sem.__doc__}\")\n\n# Função original (ou a mesma, decorada de forma diferente)\n@meu_decorador_com_wraps\ndef funcao_teste_com():\n    \"\"\"Docstring da função original (com wraps).\"\"\"\n    print(\"Executando funcao_teste_com\")\n    return \"resultado_com\"\n\nprint(\"\\n--- Teste COM wraps ---\")\nfuncao_teste_com()\nprint(f\"Nome: {funcao_teste_com.__name__}\")\nprint(f\"Docstring: {funcao_teste_com.__doc__}\")",
        "test_code": "assert \"--- Teste SEM wraps ---\" in output and \"Nome: wrapper\" in output and \"Docstring: None\" in output and \"--- Teste COM wraps ---\" in output and \"Nome: funcao_teste_com\" in output and \"Docstring: Docstring da função original (com wraps).\" in output",
        "level": "avançado"
    },
    {
        "id": "ex-estruturas-fila-1",
        "lesson_id": "estruturas-algoritmos-avancados",
        "title": "Simulando uma Fila de Processos",
        "description": "Use `collections.deque` para simular uma fila onde processos chegam e são executados. Adicione os processos 'Processo A', 'Processo B', 'Processo C' e depois 'execute' (remova) dois processos da frente da fila, imprimindo o processo executado em cada passo.",
        "difficulty": "Médio",
        "order": 1,
        "instructions": "Importe `deque` de `collections`. Crie uma instância de `deque`. Use `append()` para adicionar processos e `popleft()` para remover. Imprima o processo removido.",
        "initial_code": "from collections import deque\n\nfila_processos = deque()\n\n# Adicione os processos 'Processo A', 'Processo B', 'Processo C'\n\nprint(\"Executando processos:\")\n# Remova e imprima os dois primeiros processos\n# processo_executado_1 = ...\n# print(f\"Executado: {processo_executado_1}\")\n# processo_executado_2 = ...\n# print(f\"Executado: {processo_executado_2}\")",
        "solution_code": "from collections import deque\n\nfila_processos = deque()\n\nfila_processos.append('Processo A')\nfila_processos.append('Processo B')\nfila_processos.append('Processo C')\n\nprint(\"Executando processos:\")\nprocesso_executado_1 = fila_processos.popleft()\nprint(f\"Executado: {processo_executado_1}\")\nprocesso_executado_2 = fila_processos.popleft()\nprint(f\"Executado: {processo_executado_2}\")\n\n# Opcional: imprimir fila restante\n# print(f\"Fila restante: {list(fila_processos)}\")",
        "test_code": "assert \"Executando processos:\" in output and \"Executado: Processo A\" in output and \"Executado: Processo B\" in output",
        "level": "avançado"
    },
    {
        "id": "ex-estruturas-pilha-1",
        "lesson_id": "estruturas-algoritmos-avancados",
        "title": "Simulando uma Pilha de Chamadas de Função",
        "description": "Use uma lista Python para simular uma pilha de chamadas de função. Adicione as chamadas 'Funcao A', 'Funcao B', 'Funcao C' e depois 'retorne' (remova) as duas últimas chamadas adicionadas (seguindo a lógica LIFO - Last-In, First-Out), imprimindo a chamada retornada em cada passo.",
        "difficulty": "Médio",
        "order": 2,
        "instructions": "Use uma lista Python. Use `append()` para 'empilhar' e `pop()` para 'desempilhar'. Imprima a chamada removida.",
        "initial_code": "pilha_chamadas = []\n\n# Adicione as chamadas 'Funcao A', 'Funcao B', 'Funcao C'\n\nprint(\"Retornando chamadas:\")\n# Remova e imprima as duas últimas chamadas adicionadas\n# chamada_retornada_1 = ...\n# print(f\"Retornada: {chamada_retornada_1}\")\n# chamada_retornada_2 = ...\n# print(f\"Retornada: {chamada_retornada_2}\")",
        "solution_code": "pilha_chamadas = []\n\npilha_chamadas.append('Funcao A')\npilha_chamadas.append('Funcao B')\npilha_chamadas.append('Funcao C')\n\nprint(\"Retornando chamadas:\")\nchamada_retornada_1 = pilha_chamadas.pop()\nprint(f\"Retornada: {chamada_retornada_1}\")\nchamada_retornada_2 = pilha_chamadas.pop()\nprint(f\"Retornada: {chamada_retornada_2}\")\n\n# Opcional: imprimir pilha restante\n# print(f\"Pilha restante: {pilha_chamadas}\")",
        "test_code": "assert \"Retornando chamadas:\" in output and \"Retornada: Funcao C\" in output and \"Retornada: Funcao B\" in output",
        "level": "avançado"
    },
    {
        "id": "ex-big-o-analise-1",
        "lesson_id": "estruturas-algoritmos-avancados",
        "title": "Análise de Complexidade Big O",
        "description": "Considere a seguinte função Python. Qual é a complexidade de tempo (Time Complexity) desta função em notação Big O? Justifique brevemente.",
        "difficulty": "Médio",
        "order": 3,
        "instructions": "Analise a função fornecida no `initial_code`. Determine a operação dominante e como seu número de execuções cresce com o tamanho da entrada (`n`). Imprima sua resposta e justificativa.",
        "initial_code": "# Função para análise:\ndef exemplo_big_o(n):\n    contador = 0\n    for i in range(n):\n        contador += 1\n    return contador\n\n# Qual a complexidade de tempo (Big O)?\n# Justifique sua resposta.\n\n# print(\"A complexidade de tempo é O(...)\")\n# print(\"Justificativa: ...\")",
        "solution_code": "# Função para análise:\ndef exemplo_big_o(n):\n    contador = 0\n    for i in range(n):\n        contador += 1\n    return contador\n\nprint(\"A complexidade de tempo é O(n).\")\nprint(\"Justificativa: A operação dominante é o loop `for` que executa `n` vezes. O número de operações cresce linearmente com o tamanho da entrada `n`.\")",
        "test_code": "assert \"A complexidade de tempo é O(n).\" in output or \"A complexidade de tempo é O(N).\" in output and (\"loop `for`\" in output or \"itera\" in output or \"executa\" in output) and (\"linearmente\" in output or \"diretamente proporcional\" in output) and (\"tamanho da entrada\" in output or \"n\" in output or \"N\" in output)",
        "level": "avançado"
    },
    {
        "id": "ex-sorting-merge-sort-conceito-1",
        "lesson_id": "estruturas-algoritmos-avancados",
        "title": "Conceito do Merge Sort",
        "description": "Descreva em 2-3 frases o processo principal do algoritmo de ordenação Merge Sort, focando nas duas etapas principais: divisão e intercalação (merge).",
        "difficulty": "Médio",
        "order": 4,
        "instructions": "Explique como a lista é dividida recursivamente e como as sublistas ordenadas são combinadas. Use a função print() para sua resposta.",
        "initial_code": "# Descreva o Merge Sort aqui:\n# print(\"O Merge Sort funciona dividindo a lista...\")\n# print(\"Em seguida, as sublistas ordenadas são...\")",
        "solution_code": "print(\"O Merge Sort é um algoritmo de ordenação baseado em divisão e conquista.\")\nprint(\"Ele divide recursivamente a lista em sublistas menores até que cada sublista contenha apenas um elemento (que é considerado ordenado).\")\nprint(\"Em seguida, ele intercala (merge) as sublistas ordenadas de volta, combinando-as para produzir uma lista final completamente ordenada.\")",
        "test_code": "output_lower = output.lower()\nassert \"merge sort\" in output_lower\nassert \"dividindo\" in output_lower\nassert \"sublistas\" in output_lower\nassert \"intercala\" in output_lower or \"merge\" in output_lower\nassert \"ordenada\" in output_lower",
        "level": "avançado"
    },
    {
        "id": "ex-graphs-bfs-conceito-1",
        "lesson_id": "estruturas-algoritmos-avancados",
        "title": "Conceito de Busca em Largura (BFS)",
        "description": "Descreva em 2-3 frases como o algoritmo de Busca em Largura (BFS - Breadth-First Search) explora um grafo, mencionando a estrutura de dados que ele tipicamente utiliza para gerenciar os nós a serem visitados.",
        "difficulty": "Médio",
        "order": 5,
        "instructions": "Explique a ordem de visitação dos nós (nível por nível) e qual estrutura é usada para isso. Use a função print() para sua resposta.",
        "initial_code": "# Descreva a Busca em Largura (BFS) aqui:\n# print(\"A Busca em Largura (BFS) explora um grafo...\")\n# print(\"Ela tipicamente utiliza uma estrutura de dados do tipo...\")",
        "solution_code": "print(\"A Busca em Largura (BFS) explora um grafo nível por nível, visitando todos os vizinhos de um nó antes de passar para o próximo nível.\")\nprint(\"Ela tipicamente utiliza uma estrutura de dados do tipo fila (queue) para manter o controle dos nós a serem visitados na ordem correta.\")",
        "test_code": "assert \"Busca em Largura\" in output or \"BFS\" in output and (\"nível por nível\" in output or \"camada\" in output) and (\"fila\" in output or \"queue\" in output)",
        "level": "avançado"
    },
    {
        "id": "ex-estruturas-algoritmos-escolha-1",
        "lesson_id": "estruturas-algoritmos-avancados",
        "title": "Escolhendo a Estrutura Correta (Conceitual)",
        "description": "Você precisa armazenar uma coleção de itens onde a ordem de chegada é importante e você sempre processa o item mais antigo primeiro. Qual estrutura de dados avançada (fila, pilha, árvore, grafo) seria a mais adequada para este cenário e por quê?",
        "difficulty": "Fácil",
        "order": 6,
        "instructions": "Escolha a estrutura de dados mais adequada e justifique sua escolha com base nas características da estrutura e no requisito do problema. Imprima sua resposta.",
        "initial_code": "# Qual estrutura de dados é a mais adequada e por quê?\n# print(\"Para este cenário, a estrutura de dados mais adequada é...\")\n# print(\"Justificativa: ...\")",
        "solution_code": "print(\"Para este cenário, a estrutura de dados mais adequada é uma fila (queue).\")\nprint(\"Justificativa: Uma fila opera sob o princípio FIFO (First-In, First-Out), o que significa que o primeiro item a entrar é o primeiro a sair. Isso corresponde exatamente ao requisito de processar o item mais antigo primeiro.\")",
        "test_code": "assert (\"fila\" in output.lower() or \"queue\" in output.lower()) and (\"fifo\" in output.lower() or \"first-in, first-out\" in output.lower()) and (\"item mais antigo\" in output or \"primeiro a entrar\" in output)",
        "level": "avançado"
    },
    {
        "id": "ex-flask-intro-1",
        "lesson_id": "web-flask-intro",
        "title": "Conceito de Framework Web e Flask (Conceitual)",
        "description": "Em poucas frases, explique o que é um framework web e posicione o Flask como um microframework dentro desse contexto.",
        "difficulty": "Fácil",
        "order": 1,
        "instructions": "Use a função print() para descrever o que é um framework web e o que torna o Flask um microframework.",
        "initial_code": "# Explique o conceito de framework web e Flask aqui\n# print(\"Um framework web é...\")\n# print(\"Flask é um microframework porque...\")",
        "solution_code": "print(\"Um framework web é uma estrutura que fornece ferramentas e bibliotecas para simplificar o desenvolvimento de aplicações web.\")\nprint(\"Flask é considerado um microframework porque oferece funcionalidades essenciais de forma minimalista, deixando muitas decisões e a escolha de componentes adicionais para o desenvolvedor.\")",
        "test_code": "assert \"framework web\" in output.lower() and \"flask\" in output.lower() and \"microframework\" in output.lower()",
        "level": "avançado"
    },
    {
        "id": "ex-flask-instalacao-1",
        "lesson_id": "web-flask-intro",
        "title": "Instalação do Flask (Simulado)",
        "description": "Qual comando você usaria no terminal para instalar o Flask usando o pip, o gerenciador de pacotes do Python? Imprima este comando.",
        "difficulty": "Fácil",
        "order": 2,
        "instructions": "Imprima a linha de comando exata para instalar o Flask via pip.",
        "initial_code": "# Imprima o comando de instalação do Flask aqui\n# print(\"...\")",
        "solution_code": "print(\"pip install Flask\")",
        "test_code": "assert output.strip() == \"pip install Flask\"",
        "level": "avançado"
    },
    {
        "id": "ex-flask-app-simples-1",
        "lesson_id": "web-flask-intro",
        "title": "Estrutura Básica de uma Aplicação Flask (Simulado)",
        "description": "Simule o código Python mínimo necessário para criar uma instância básica de uma aplicação Flask. Imprima uma mensagem confirmando a criação simulada.",
        "difficulty": "Fácil",
        "order": 3,
        "instructions": "Importe `Flask` e crie uma instância `app = Flask(__name__)`. Imprima uma mensagem indicando que a aplicação foi criada.",
        "initial_code": "# Simule a criação da aplicação Flask aqui\n# from flask import Flask\n# app = Flask(__name__)\n\n# Imprima a mensagem de confirmação\n# print(\"...\")",
        "solution_code": "from flask import Flask\n# A linha abaixo simula a criação da instância app\n# app = Flask(__name__)\n\nprint(\"Instância básica da aplicação Flask criada (simulado).\")",
        "test_code": "assert \"Instância básica da aplicação Flask criada (simulado).\" in output",
        "level": "avançado"
    },
    {
        "id": "ex-flask-rota-texto-1",
        "lesson_id": "web-flask-intro",
        "title": "Definindo uma Rota Simples com Resposta de Texto",
        "description": "Crie uma aplicação Flask simulada com uma rota raiz (`/`) que retorna a string \"Olá, Flask!\".",
        "difficulty": "Médio",
        "order": 4,
        "instructions": "Importe `Flask`. Crie a instância `app`. Use o decorador `@app.route('/')` para definir a rota. Crie uma função de view que retorne a string desejada. Para o teste, simule a chamada da rota e imprima o resultado retornado pela função de view.",
        "initial_code": "# from flask import Flask\n# app = Flask(__name__)\n\n# Defina a rota raiz e a função de view aqui\n# @app.route('/')\n# def index():\n#     return \"Olá, Flask!\"\n\n# Simule a chamada da rota para o teste\n# print(index())",
        "solution_code": "from flask import Flask\n# app = Flask(__name__)\n\n# Defina a rota raiz e a função de view\n# Em um app real, isso estaria associado à instância 'app'\ndef index():\n    return \"Olá, Flask!\"\n\n# Simule a chamada da rota para o teste automatizado\nprint(index())",
        "test_code": "assert output.strip() == \"Olá, Flask!\"",
        "level": "avançado"
    },
    {
        "id": "ex-flask-rota-dinamica-1",
        "lesson_id": "web-flask-intro",
        "title": "Definindo uma Rota com Parâmetro Dinâmico",
        "description": "Crie uma rota Flask simulada `/saudacao/<nome>` que capture o parâmetro `nome` da URL e retorne a string \"Olá, [nome]!\".",
        "difficulty": "Médio",
        "order": 5,
        "instructions": "Use o decorador `@app.route('/saudacao/<nome>')`. A função de view deve aceitar o parâmetro `nome`. Retorne a string formatada. Simule a chamada da função de view com um nome para o teste.",
        "initial_code": "# from flask import Flask\n# app = Flask(__name__)\n\n# Defina a rota dinâmica e a função de view aqui\n# @app.route('/saudacao/<nome>')\n# def saudacao(nome):\n#     return f\"Olá, {nome}!\"\n\n# Simule a chamada da rota com um nome para o teste\n# print(saudacao(\"Mundo\"))",
        "solution_code": "from flask import Flask\n# app = Flask(__name__)\n\n# Defina a rota dinâmica e a função de view\n# Em um app real, isso estaria associado à instância 'app'\ndef saudacao(nome):\n    return f\"Olá, {nome}!\"\n\n# Simule a chamada da rota com um nome para o teste automatizado\nprint(saudacao(\"AstroDev\"))",
        "test_code": "assert output.strip() == \"Olá, AstroDev!\"",
        "level": "avançado"
    },
    {
        "id": "ex-flask-template-simples-1",
        "lesson_id": "web-flask-intro",
        "title": "Renderizando um Template HTML Simples (Simulado)",
        "description": "Simule o uso da função `render_template` do Flask para 'renderizar' um template HTML básico chamado `index.html`. Imprima uma mensagem confirmando que o template seria renderizado.",
        "difficulty": "Médio",
        "order": 6,
        "instructions": "Importe `render_template` de `flask`. Crie uma função de view que 'chame' `render_template('index.html')`. Imprima uma mensagem indicando a simulação da renderização.",
        "initial_code": "# from flask import Flask, render_template\n# app = Flask(__name__)\n\n# Simule a função de view que renderiza um template\n# def pagina_inicial():\n#     # Simule a chamada: render_template('index.html')\n#     print(\"Simulando renderização do template 'index.html'...\")\n#     return \"HTML simulado do template\"\n\n# Simule a chamada da função de view para o teste\n# pagina_inicial()",
        "solution_code": "from flask import Flask, render_template\n# app = Flask(__name__)\n\n# Simula a função de view que renderiza um template\ndef pagina_inicial():\n    # Em um app real, isso renderizaria o template\n    # return render_template('index.html')\n    print(\"Simulando renderização do template 'index.html'...\")\n    # Retorna um placeholder para o teste\n    return \"\"\n\n# Simule a chamada da função de view para o teste automatizado\npagina_inicial()",
        "test_code": "assert \"Simulando renderização do template 'index.html'\" in output",
        "level": "avançado"
    },
    {
        "id": "ex-flask-template-dados-1",
        "lesson_id": "web-flask-intro",
        "title": "Passando Dados para um Template (Simulado)",
        "description": "Simule o uso de `render_template` para passar uma variável, como um `titulo` para um template HTML chamado `pagina.html`. Imprima uma mensagem indicando a simulação e o dado que seria passado.",
        "difficulty": "Médio",
        "order": 7,
        "instructions": "Importe `render_template`. Crie uma função de view. Dentro dela, defina uma variável (ex: `titulo = \"Minha Página\"`). Simule a chamada `render_template('pagina.html', titulo=titulo)`. Imprima uma mensagem indicando a simulação e o valor da variável.",
        "initial_code": "# from flask import Flask, render_template\n# app = Flask(__name__)\n\n# Simule a função de view que passa dados para um template\n# def exibir_pagina():\n#     titulo_pagina = \"Página Dinâmica\"\n#     # Simule a chamada: render_template('pagina.html', titulo=titulo_pagina)\n#     print(f\"Simulando renderização de 'pagina.html' com titulo='{titulo_pagina}'...\")\n#     return \"HTML simulado com dados\"\n\n# Simule a chamada da função de view para o teste\n# exibir_pagina()",
        "solution_code": "from flask import Flask, render_template\n# app = Flask(__name__)\n\n# Simula a função de view que passa dados para um template\ndef exibir_pagina():\n    titulo_pagina = \"Página Dinâmica com Dados\"\n    # Em um app real, isso renderizaria o template passando 'titulo_pagina'\n    # return render_template('pagina.html', titulo=titulo_pagina)\n    print(f\"Simulando renderização de 'pagina.html' com titulo='{titulo_pagina}'...\")\n    # Retorna um placeholder para o teste\n    return f\"\"\n\n# Simule a chamada da função de view para o teste automatizado\nexibir_pagina()",
        "test_code": "assert \"Simulando renderização de 'pagina.html' com titulo='Página Dinâmica com Dados'\" in output",
        "level": "avançado"
    },
    {
        "id": "ex-numpy-array-criação-1",
        "lesson_id": "data-science-numpy-pandas",
        "title": "Criando um Array NumPy Básico",
        "description": "Use a biblioteca NumPy para criar um array unidimensional contendo os números de 1 a 5.",
        "difficulty": "Fácil",
        "order": 1,
        "instructions": "Importe a biblioteca NumPy como `np`. Use `np.array()` para criar o array com a lista `[1, 2, 3, 4, 5]`. Imprima o array criado.",
        "initial_code": "import numpy as np\n\n# Crie o array NumPy aqui\n# meu_array = ...\n\n# Imprima o array\n# print(meu_array)",
        "solution_code": "import numpy as np\n\nmeu_array = np.array([1, 2, 3, 4, 5])\n\nprint(meu_array)",
        "test_code": "import numpy as np\nexpected_output = np.array([1, 2, 3, 4, 5])\ntry:\n    # Avalia a saída como um array numpy (pode ser complexo dependendo da formatação)\n    # Uma abordagem mais robusta seria capturar stdout e parsear, mas para testes simples...\n    # Vamos verificar se a string de saída contém os elementos esperados\n    assert '[1 2 3 4 5]' in output.strip() or '[1  2  3  4  5]' in output.strip()\nexcept:\n    assert False, \"Saída não parece ser o array NumPy esperado.\"",
        "level": "avançado"
    },
    {
        "id": "ex-numpy-operacoes-basicas-1",
        "lesson_id": "data-science-numpy-pandas",
        "title": "Operações Matemáticas com Arrays NumPy",
        "description": "Crie dois arrays NumPy: `arr1 = np.array([1, 2, 3])` e `arr2 = np.array([4, 5, 6])`. Calcule e imprima a soma e o produto elemento a elemento desses dois arrays.",
        "difficulty": "Fácil",
        "order": 2,
        "instructions": "Use os operadores `+` e `*` diretamente nos arrays NumPy para realizar as operações vetorizadas. Imprima o resultado de cada operação.",
        "initial_code": "import numpy as np\n\narr1 = np.array([1, 2, 3])\narr2 = np.array([4, 5, 6])\n\n# Calcule a soma dos arrays\n# soma_arrays = ...\n# print(f\"Soma: {soma_arrays}\")\n\n# Calcule o produto dos arrays (elemento a elemento)\n# produto_arrays = ...\n# print(f\"Produto: {produto_arrays}\")",
        "solution_code": "import numpy as np\n\narr1 = np.array([1, 2, 3])\narr2 = np.array([4, 5, 6])\n\nsoma_arrays = arr1 + arr2\nprint(f\"Soma: {soma_arrays}\")\n\nproduto_arrays = arr1 * arr2\nprint(f\"Produto: {produto_arrays}\")",
        "test_code": "assert \"Soma: [5 7 9]\" in output and \"Produto: [ 4 10 18]\" in output",
        "level": "avançado"
    },
    {
        "id": "ex-numpy-filtragem-1",
        "lesson_id": "data-science-numpy-pandas",
        "title": "Filtrando Elementos de um Array NumPy",
        "description": "Dado o array `data = np.array([10, 25, 5, 40, 15, 30])`, use indexação booleana para selecionar e imprimir apenas os elementos que são maiores que 20.",
        "difficulty": "Médio",
        "order": 3,
        "instructions": "Crie uma condição booleana (ex: `data > 20`). Use esta condição para indexar o array `data` e imprima o resultado.",
        "initial_code": "import numpy as np\n\ndata = np.array([10, 25, 5, 40, 15, 30])\n\n# Crie a condição booleana e use-a para filtrar o array\n# elementos_maiores_que_20 = ...\n\n# Imprima os elementos filtrados\n# print(elementos_maiores_que_20)",
        "solution_code": "import numpy as np\n\ndata = np.array([10, 25, 5, 40, 15, 30])\n\n# Cria a condição booleana\ncondicao = data > 20\n\n# Usa a condição para filtrar o array\nelementos_maiores_que_20 = data[condicao]\n\nprint(elementos_maiores_que_20)",
        "test_code": "import numpy as np\nexpected_output = np.array([25, 40, 30])\n# Comparação de arrays numpy na saída\nassert np.array_equal(np.fromstring(output.strip().replace('[', '').replace(']', ''), sep=' '), expected_output)",
        "level": "avançado"
    },
    {
        "id": "ex-pandas-series-1",
        "lesson_id": "data-science-numpy-pandas",
        "title": "Criando uma Série Pandas",
        "description": "Use a biblioteca Pandas para criar uma Série a partir de uma lista de frutas: `['Maçã', 'Banana', 'Laranja']`. Imprima a Série criada.",
        "difficulty": "Fácil",
        "order": 4,
        "instructions": "Importe a biblioteca Pandas como `pd`. Use `pd.Series()` para criar a Série com a lista fornecida. Imprima a Série.",
        "initial_code": "import pandas as pd\n\nlista_frutas = ['Maçã', 'Banana', 'Laranja']\n\n# Crie a Série Pandas aqui\n# serie_frutas = ...\n\n# Imprima a Série\n# print(serie_frutas)",
        "solution_code": "import pandas as pd\n\nlista_frutas = ['Maçã', 'Banana', 'Laranja']\n\nserie_frutas = pd.Series(lista_frutas)\n\nprint(serie_frutas)",
        "test_code": "assert \"0       Maçã\" in output and \"1     Banana\" in output and \"2    Laranja\" in output and \"dtype: object\" in output",
        "level": "avançado"
    },
    {
        "id": "ex-pandas-dataframe-criação-1",
        "lesson_id": "data-science-numpy-pandas",
        "title": "Criando um DataFrame Pandas a partir de um Dicionário",
        "description": "Crie um DataFrame Pandas a partir do seguinte dicionário: `{'Nome': ['Alice', 'Bob', 'Charlie'], 'Idade': [25, 30, 35], 'Cidade': ['São Paulo', 'Rio de Janeiro', 'Belo Horizonte']}`. Imprima o DataFrame criado.",
        "difficulty": "Médio",
        "order": 5,
        "instructions": "Importe Pandas. Use `pd.DataFrame()` com o dicionário fornecido. Imprima o DataFrame.",
        "initial_code": "import pandas as pd\n\ndados = {\n    'Nome': ['Alice', 'Bob', 'Charlie'],\n    'Idade': [25, 30, 35],\n    'Cidade': ['São Paulo', 'Rio de Janeiro', 'Belo Horizonte']\n}\n\n# Crie o DataFrame Pandas aqui\n# df_pessoas = ...\n\n# Imprima o DataFrame\n# print(df_pessoas)",
        "solution_code": "import pandas as pd\n\ndados = {\n    'Nome': ['Alice', 'Bob', 'Charlie'],\n    'Idade': [25, 30, 35],\n    'Cidade': ['São Paulo', 'Rio de Janeiro', 'Belo Horizonte']\n}\n\ndf_pessoas = pd.DataFrame(dados)\n\nprint(df_pessoas)",
        "test_code": "assert 'Nome' in output and 'Idade' in output and 'Cidade' in output and 'Alice' in output and 'Bob' in output and 'Charlie' in output and '25' in output and '30' in output and '35' in output",
        "level": "avançado"
    },
    {
        "id": "ex-pandas-carregar-csv-simulado-1",
        "lesson_id": "data-science-numpy-pandas",
        "title": "Carregando Dados de um CSV (Simulado)",
        "description": "Simule o carregamento de dados de uma string CSV usando `io.StringIO` e `pd.read_csv()`. A string CSV é: `'A,B,C\\n1,4,7\\n2,5,8\\n3,6,9'`. Imprima o DataFrame resultante.",
        "difficulty": "Médio",
        "order": 6,
        "instructions": "Importe Pandas e `io`. Crie a string CSV. Use `io.StringIO()` para criar um objeto similar a um arquivo. Use `pd.read_csv()` com este objeto. Imprima o DataFrame.",
        "initial_code": "import pandas as pd\nimport io\n\ncsv_data = 'A,B,C\\n1,4,7\\n2,5,8\\n3,6,9'\n\n# Use io.StringIO para simular um arquivo\n# arquivo_simulado = io.StringIO(csv_data)\n\n# Carregue o CSV simulado em um DataFrame\n# df_csv = pd.read_csv(arquivo_simulado)\n\n# Imprima o DataFrame\n# print(df_csv)",
        "solution_code": "import pandas as pd\nimport io\n\ncsv_data = 'A,B,C\\n1,4,7\\n2,5,8\\n3,6,9'\n\narquivo_simulado = io.StringIO(csv_data)\n\ndf_csv = pd.read_csv(arquivo_simulado)\n\nprint(df_csv)",
        "test_code": "assert ' A  B  C' in output or ' A   B   C' in output and '0  1  4  7' in output or '0    1    4    7' in output and '1  2  5  8' in output or '1    2    5    8' in output and '2  3  6  9' in output or '2    3    6    9' in output",
        "level": "avançado"
    },
    {
        "id": "ex-pandas-selecao-filtragem-1",
        "lesson_id": "data-science-numpy-pandas",
        "title": "Seleção de Colunas e Filtragem de Linhas com Pandas",
        "description": "Dado o DataFrame criado no exercício anterior (`df_pessoas`), selecione e imprima apenas a coluna 'Nome'. Em seguida, filtre e imprima apenas as linhas onde a 'Idade' é maior que 28.",
        "difficulty": "Médio",
        "order": 7,
        "instructions": "Use a notação de colchetes `[]` com o nome da coluna para selecionar uma única coluna. Use indexação booleana com uma condição na coluna 'Idade' para filtrar as linhas.",
        "initial_code": "import pandas as pd\n\ndados = {\n    'Nome': ['Alice', 'Bob', 'Charlie'],\n    'Idade': [25, 30, 35],\n    'Cidade': ['São Paulo', 'Rio de Janeiro', 'Belo Horizonte']\n}\ndf_pessoas = pd.DataFrame(dados)\n\n# Selecione e imprima apenas a coluna 'Nome'\n# nomes = ...\n# print(\"\\nColuna Nome:\")\n# print(nomes)\n\n# Filtre e imprima linhas onde a idade é > 28\n# pessoas_mais_velhas = ...\n# print(\"\\nPessoas com mais de 28 anos:\")\n# print(pessoas_mais_velhas)",
        "solution_code": "import pandas as pd\n\ndados = {\n    'Nome': ['Alice', 'Bob', 'Charlie'],\n    'Idade': [25, 30, 35],\n    'Cidade': ['São Paulo', 'Rio de Janeiro', 'Belo Horizonte']\n}\ndf_pessoas = pd.DataFrame(dados)\n\n# Seleciona a coluna 'Nome'\nnomes = df_pessoas['Nome']\nprint(\"Coluna Nome:\")\nprint(nomes)\n\n# Filtra linhas onde a idade é > 28\npessoas_mais_velhas = df_pessoas[df_pessoas['Idade'] > 28]\nprint(\"\\nPessoas com mais de 28 anos:\")\nprint(pessoas_mais_velhas)",
        "test_code": "assert \"Coluna Nome:\" in output\nassert \"Alice\" in output and \"Bob\" in output and \"Charlie\" in output # Verifica nomes\nassert \"Name: Nome, dtype: object\" in output\nassert \"Pessoas com mais de 28 anos:\" in output\n# Para a parte filtrada, verificar a presença de Bob e Charlie e ausência de Alice na seção correta\n# Isso é mais difícil com string matching. Idealmente, o solution_code retornaria o DataFrame filtrado.\n# Uma verificação mais simples (mas menos robusta) para a saída atual:\nassert \"Bob\" in output[output.find(\"Pessoas com mais de 28 anos:\"):]\nassert \"Charlie\" in output[output.find(\"Pessoas com mais de 28 anos:\"):]\nassert \"Alice\" not in output[output.find(\"Pessoas com mais de 28 anos:\"):]",
        "level": "avançado"
    },
    {
        "id": "ex-pandas-missing-values-conceito-1",
        "lesson_id": "data-science-numpy-pandas",
        "title": "Tratamento de Valores Ausentes (Conceitual)",
        "description": "Em Pandas, qual valor especial é comumente usado para representar dados ausentes ou 'Não Disponível' (Not a Number)? Mencione dois métodos comuns de DataFrames Pandas para lidar com esses valores ausentes.",
        "difficulty": "Fácil",
        "order": 8,
        "instructions": "Identifique o valor usado para dados ausentes e dois métodos Pandas para gerenciá-los. Imprima o valor e os nomes dos dois métodos.",
        "initial_code": "# Qual valor representa dados ausentes em Pandas?\n# Quais dois métodos comuns são usados para lidar com eles?\n# print(\"Valor para dados ausentes: ...\")\n# print(\"Método 1: ...()\")\n# print(\"Método 2: ...()\")",
        "solution_code": "print(\"Valor para dados ausentes: NaN (Not a Number).\")\nprint(\"Método 1: dropna() (remove linhas/colunas com NaN)\")\nprint(\"Método 2: fillna() (preenche NaN com um valor específico ou método)\")",
        "test_code": "assert \"Valor para dados ausentes: NaN\" in output and \"Método 1: dropna()\" in output and \"Método 2: fillna()\" in output",
        "level": "avançado"
    },
    {
        "id": "ex-sklearn-ml-tipos-conceito-1",
        "lesson_id": "data-science-matplotlib-sklearn",
        "title": "Tipos de Machine Learning (Conceitual)",
        "description": "Explique a diferença fundamental entre Aprendizado Supervisionado e Aprendizado Não Supervisionado em Machine Learning. Dê um exemplo de aplicação para cada um.",
        "difficulty": "Fácil",
        "order": 5,
        "instructions": "Descreva cada tipo de aprendizado e forneça um exemplo prático. Use a função print() para sua resposta.",
        "initial_code": "# Explique Aprendizado Supervisionado e Não Supervisionado aqui\n# print(\"Aprendizado Supervisionado: ... Exemplo: ...\")\n# print(\"Aprendizado Não Supervisionado: ... Exemplo: ...\")",
        "solution_code": "print(\"Aprendizado Supervisionado: Utiliza dados rotulados (com pares entrada-saída conhecidos) para treinar um modelo a prever a saída para novas entradas. Exemplo: Prever o preço de uma casa com base em suas características (Regressão) ou classificar e-mails como spam/não spam (Classificação).\")\nprint(\"Aprendizado Não Supervisionado: Utiliza dados sem rótulos para encontrar padrões, estruturas ou relacionamentos ocultos nos dados. Exemplo: Agrupar clientes com comportamentos de compra semelhantes (Clustering) ou detectar anomalias em dados de rede.\")",
        "test_code": "assert \"Aprendizado Supervisionado\" in output and \"rotulados\" in output.lower() and (\"prever\" in output.lower() or \"classificar\" in output.lower()) and \"Aprendizado Não Supervisionado\" in output and \"sem rótulos\" in output.lower() and (\"padrões\" in output.lower() or \"estruturas\" in output.lower() or \"agrupar\" in output.lower())",
        "level": "avançado"
    },
    {
        "id": "ex-sklearn-regressao-simples-1",
        "lesson_id": "data-science-matplotlib-sklearn",
        "title": "Implementando Regressão Linear Simples (Simulado)",
        "description": "Simule a implementação de um modelo de Regressão Linear Simples usando Scikit-learn. Crie dados de exemplo simples (X e y), instancie `LinearRegression`, 'treine' o modelo com `fit()` e 'faça uma previsão' com `predict()`. Imprima a previsão simulada.",
        "difficulty": "Médio",
        "order": 6,
        "instructions": "Importe `LinearRegression` de `sklearn.linear_model`. Crie arrays NumPy simples para X (entrada, 2D) e y (saída, 1D). Instancie o modelo. Chame `fit(X, y)`. Chame `predict(X_novo)` com um novo ponto X. Imprima a previsão.",
        "initial_code": "import numpy as np\n# from sklearn.linear_model import LinearRegression\n\n# Dados de exemplo (simples)\nX = np.array([[1], [2], [3], [4], [5]]) # Entrada (features)\ny = np.array([2, 4, 5, 4, 5]) # Saída (target)\n\n# Instancie o modelo de Regressão Linear\n# modelo = LinearRegression()\n\n# 'Treine' o modelo (simulado)\n# modelo.fit(X, y)\n# print(\"Modelo de Regressão Linear treinado (simulado).\")\n\n# Dados para nova previsão\n# X_novo = np.array([[6]])\n\n# Faça uma previsão (simulado)\n# previsao = modelo.predict(X_novo)\n# print(f\"Previsão para X=6: {previsao[0]:.2f}\")",
        "solution_code": "import numpy as np\nfrom sklearn.linear_model import LinearRegression\n\n# Dados de exemplo (simples)\nX = np.array([[1], [2], [3], [4], [5]]) # Entrada (features)\ny = np.array([2, 4, 5, 4, 5]) # Saída (target)\n\n# Instancia o modelo de Regressão Linear\nmodelo = LinearRegression()\n\n# 'Treina' o modelo\nmodelo.fit(X, y)\nprint(\"Modelo de Regressão Linear treinado.\")\n\n# Dados para nova previsão\nX_novo = np.array([[6]])\n\n# Faz uma previsão\nprevisao = modelo.predict(X_novo)\nprint(f\"Previsão para X=6: {previsao[0]:.2f}\")",
        "test_code": "assert \"Modelo de Regressão Linear treinado.\" in output and \"Previsão para X=6:\" in output and \"5.80\" in output",
        "level": "avançado"
    },
    {
        "id": "ex-sklearn-classificacao-simples-1",
        "lesson_id": "data-science-matplotlib-sklearn",
        "title": "Implementando Classificação Simples (Simulado)",
        "description": "Simule a implementação de um modelo de Classificação simples (ex: K-Nearest Neighbors) usando Scikit-learn. Crie dados de exemplo (X e y), instancie o classificador, 'treine' com `fit()` e 'faça uma previsão' com `predict()`. Imprima a previsão simulada.",
        "difficulty": "Médio",
        "order": 7,
        "instructions": "Importe `KNeighborsClassifier` de `sklearn.neighbors`. Crie arrays NumPy simples para X (entrada, 2D) e y (rótulos, 1D). Instancie o classificador. Chame `fit(X, y)`. Chame `predict(X_novo)` com um novo ponto X. Imprima a previsão.",
        "initial_code": "import numpy as np\n# from sklearn.neighbors import KNeighborsClassifier\n\n# Dados de exemplo (simples, 2 classes: 0 e 1)\nX = np.array([[1, 2], [1, 3], [2, 3], [3, 1], [3, 2]]) # Entrada (features)\ny = np.array([0, 0, 0, 1, 1]) # Saída (rótulos/classes)\n\n# Instancie o classificador (ex: com n_neighbors=3)\n# modelo = KNeighborsClassifier(n_neighbors=3)\n\n# 'Treine' o modelo (simulado)\n# modelo.fit(X, y)\n# print(\"Classificador K-NN treinado (simulado).\")\n\n# Dados para nova previsão\n# X_novo = np.array([[2, 1]])\n\n# Faça uma previsão (simulado)\n# previsao = modelo.predict(X_novo)\n# print(f\"Previsão para X_novo=[2, 1]: Classe {previsao[0]}\")",
        "solution_code": "import numpy as np\nfrom sklearn.neighbors import KNeighborsClassifier\n\n# Dados de exemplo (simples, 2 classes: 0 e 1)\nX = np.array([[1, 2], [1, 3], [2, 3], [3, 1], [3, 2]]) # Entrada (features)\ny = np.array([0, 0, 0, 1, 1]) # Saída (rótulos/classes)\n\n# Instancia o classificador (ex: com n_neighbors=3)\nmodelo = KNeighborsClassifier(n_neighbors=3)\n\n# 'Treina' o modelo\nmodelo.fit(X, y)\nprint(\"Classificador K-NN treinado.\")\n\n# Dados para nova previsão\nX_novo = np.array([[2, 1]])\n\n# Faz uma previsão\nprevisao = modelo.predict(X_novo)\nprint(f\"Previsão para X_novo=[2, 1]: Classe {previsao[0]}\")",
        "test_code": "assert \"Classificador K-NN treinado.\" in output and \"Previsão para X_novo=[2, 1]: Classe\" in output and (\"Classe 0\" in output or \"Classe 1\" in output)",
        "level": "avançado"
    },
    {
        "id": "ex-sklearn-avaliacao-conceito-1",
        "lesson_id": "data-science-matplotlib-sklearn",
        "title": "Métricas de Avaliação de Modelos (Conceitual)",
        "description": "Mencione duas métricas comuns usadas para avaliar o desempenho de modelos de Classificação e duas métricas comuns para modelos de Regressão em Machine Learning.",
        "difficulty": "Fácil",
        "order": 8,
        "instructions": "Liste duas métricas para classificação e duas para regressão. Use a função print() para sua resposta.",
        "initial_code": "# Mencione métricas de avaliação aqui\n# print(\"Métricas para Classificação: ...\")\n# print(\"Métricas para Regressão: ...\")",
        "solution_code": "print(\"Métricas comuns para avaliar modelos de Classificação: Acurácia, Precisão, Recall, F1-Score, Área sob a Curva ROC.\")\nprint(\"Métricas comuns para avaliar modelos de Regressão: Erro Quadrático Médio (MSE), Raiz do Erro Quadrático Médio (RMSE), Erro Médio Absoluto (MAE), R² (Coeficiente de Determinação).\")",
        "test_code": "assert \"Métricas comuns para avaliar modelos de Classificação:\" in output and (\"Acurácia\" in output or \"Precisão\" in output or \"Recall\" in output) and \"Métricas comuns para avaliar modelos de Regressão:\" in output and (\"Erro Quadrático Médio\" in output or \"RMSE\" in output or \"R²\" in output)",
        "level": "avançado"
    },
    {
        "id": "ex-sklearn-workflow-conceito-1",
        "lesson_id": "data-science-matplotlib-sklearn",
        "title": "Fluxo Básico de um Projeto de ML (Conceitual)",
        "description": "Liste as principais etapas do fluxo de trabalho básico em um projeto de Machine Learning, desde os dados até a avaliação do modelo.",
        "difficulty": "Fácil",
        "order": 9,
        "instructions": "Pense nas etapas como: coleta/preparação de dados, escolha/treinamento do modelo, e avaliação. Use a função print() para listar as etapas.",
        "initial_code": "# Liste as etapas do fluxo de trabalho de ML aqui\n# print(\"Etapa 1: ...\")\n# print(\"Etapa 2: ...\")\n# print(\"Etapa 3: ...\")\n# ...",
        "solution_code": "print(\"Fluxo de trabalho básico em um projeto de Machine Learning:\")\nprint(\"1. Coleta e Preparação dos Dados (limpeza, transformação, seleção de features).\")\nprint(\"2. Escolha do Modelo (selecionar o algoritmo apropriado).\")\nprint(\"3. Treinamento do Modelo (ajustar o modelo aos dados de treino).\")\nprint(\"4. Avaliação do Modelo (medir o desempenho com dados de teste).\")\nprint(\"5. Ajuste de Hiperparâmetros e Iteração (refinar o modelo).\")\nprint(\"6. Implantação (colocar o modelo em produção).\")",
        "test_code": "assert \"Fluxo de trabalho básico em um projeto de Machine Learning:\" in output and \"Coleta e Preparação\" in output and \"Escolha do Modelo\" in output and \"Treinamento do Modelo\" in output and \"Avaliação do Modelo\" in output",
        "level": "avançado"
    },
    {
        "id": "ex-conc-par-conceito-1",
        "lesson_id": "concorrencia-paralelismo",
        "title": "Concorrência vs Paralelismo (Conceitual)",
        "description": "Explique a diferença fundamental entre Concorrência e Paralelismo em programação. Use analogias simples se ajudar.",
        "difficulty": "Fácil",
        "order": 1,
        "instructions": "Descreva cada conceito e a principal distinção entre eles. Use a função print() para sua resposta.",
        "initial_code": "# Explique Concorrência e Paralelismo aqui\n# print(\"Concorrência é...\")\n# print(\"Paralelismo é...\")\n# print(\"A principal diferença é...\")",
        "solution_code": "print(\"Concorrência é a capacidade de um sistema lidar com muitas tarefas 'ao mesmo tempo', alternando entre elas. Pense em um garçom atendendo várias mesas.\")\nprint(\"Paralelismo é a execução real de múltiplas tarefas simultaneamente, geralmente em processadores ou núcleos diferentes. Pense em vários garçons atendendo várias mesas ao mesmo tempo.\")\nprint(\"A principal diferença é que concorrência lida com muitas coisas de uma vez (gerenciamento de tempo), enquanto paralelismo faz muitas coisas ao mesmo tempo (execução simultânea).\")",
        "test_code": "assert \"Concorrência\" in output and \"Paralelismo\" in output and (\"ao mesmo tempo\" in output or \"simultaneamente\" in output) and (\"alternando\" in output or \"múltiplos processadores\" in output)",
        "level": "avançado"
    },
    {
        "id": "ex-gil-conceito-1",
        "lesson_id": "concorrencia-paralelismo",
        "title": "O GIL (Global Interpreter Lock) (Conceitual)",
        "description": "Explique o que é o GIL (Global Interpreter Lock) em CPython e qual sua principal implicação para a execução de threads em sistemas multi-core.",
        "difficulty": "Médio",
        "order": 2,
        "instructions": "Descreva o propósito do GIL e como ele afeta a execução paralela de código Python em CPU bound tasks. Use a função print() para sua resposta.",
        "initial_code": "# Explique o GIL e suas implicações aqui\n# print(\"O GIL (Global Interpreter Lock) é...\")\n# print(\"Sua principal implicação é que...\")",
        "solution_code": "print(\"O GIL (Global Interpreter Lock) é um mutex que protege o acesso a objetos Python, impedindo que múltiplas threads nativas executem bytecode Python simultaneamente em múltiplos núcleos de CPU.\")\nprint(\"Sua principal implicação é que, para tarefas que consomem muita CPU (CPU-bound), o GIL impede o paralelismo real de threads em sistemas multi-core. Para tarefas de I/O (I/O-bound), o GIL é liberado, permitindo concorrência.\")",
        "test_code": "assert \"GIL\" in output and \"Global Interpreter Lock\" in output and (\"mutex\" in output or \"impede\" in output) and (\"threads nativas\" in output or \"bytecode Python\" in output) and (\"multi-core\" in output or \"múltiplos núcleos\" in output) and (\"paralelismo real\" in output or \"CPU-bound\" in output) and (\"I/O-bound\" in output or \"liberado\" in output)",
        "level": "avançado"
    },
    {
        "id": "ex-threading-simples-2",
        "lesson_id": "concorrencia-paralelismo",
        "title": "Criando e Executando Múltiplas Threads",
        "description": "Crie duas threads, cada uma executando uma função simples que imprime uma mensagem e espera por um curto período de tempo. Inicie ambas as threads e espere que elas terminem.",
        "difficulty": "Médio",
        "order": 3,
        "instructions": "Importe `threading` e `time`. Defina duas funções, `tarefa1` e `tarefa2`, que imprimem mensagens e usam `time.sleep()`. Crie duas instâncias de `threading.Thread`, uma para cada função. Chame `start()` em ambas e `join()` em ambas.",
        "initial_code": "import threading\nimport time\n\ndef tarefa1():\n    print(\"Tarefa 1: Iniciada\")\n    time.sleep(0.5)\n    print(\"Tarefa 1: Finalizada\")\n\ndef tarefa2():\n    print(\"Tarefa 2: Iniciada\")\n    time.sleep(0.7)\n    print(\"Tarefa 2: Finalizada\")\n\n# Crie as threads para tarefa1 e tarefa2\n# thread1 = ...\n# thread2 = ...\n\nprint(\"Programa principal: Iniciando threads\")\n\n# Inicie as threads\n# ...\n# ...\n\n# Espere as threads terminarem\n# ...\n# ...\n\nprint(\"Programa principal: Todas as threads finalizadas.\")",
        "solution_code": "import threading\nimport time\n\ndef tarefa1():\n    print(\"Tarefa 1: Iniciada\")\n    time.sleep(0.5)\n    print(\"Tarefa 1: Finalizada\")\n\ndef tarefa2():\n    print(\"Tarefa 2: Iniciada\")\n    time.sleep(0.7)\n    print(\"Tarefa 2: Finalizada\")\n\n# Crie as threads\nthread1 = threading.Thread(target=tarefa1)\nthread2 = threading.Thread(target=tarefa2)\n\nprint(\"Programa principal: Iniciando threads\")\n\n# Inicie as threads\nthread1.start()\nthread2.start()\n\n# Espere as threads terminarem\nthread1.join()\nthread2.join()\n\nprint(\"Programa principal: Todas as threads finalizadas.\")",
        "test_code": "assert \"Programa principal: Iniciando threads\" in output and \"Tarefa 1: Iniciada\" in output and \"Tarefa 2: Iniciada\" in output and \"Tarefa 1: Finalizada\" in output and \"Tarefa 2: Finalizada\" in output and \"Programa principal: Todas as threads finalizadas.\" in output",
        "level": "avançado"
    },
    {
        "id": "ex-threading-lock-1",
        "lesson_id": "concorrencia-paralelismo",
        "title": "Sincronização com Lock: Evitando Race Condition",
        "description": "Simule um cenário de 'race condition' onde múltiplas threads tentam modificar uma variável compartilhada sem sincronização. Em seguida, use `threading.Lock` para proteger o acesso à variável e resolver a 'race condition'.",
        "difficulty": "Difícil",
        "order": 4,
        "instructions": "Defina uma variável global `contador = 0`. Crie uma função `incrementar()` que lê `contador`, espera um pouco (`time.sleep(0.01)`), incrementa e escreve de volta. Crie várias threads executando `incrementar()`. Observe que o resultado final é menor que o esperado. Depois, adicione um `threading.Lock` e use `lock.acquire()` e `lock.release()` (ou um `with lock:`) dentro da função `incrementar()` para proteger a seção crítica.",
        "initial_code": "import threading\nimport time\n\ncontador = 0\n# lock = threading.Lock() # Descomente para usar o lock\n\ndef incrementar():\n    global contador\n    # Adquira o lock aqui (se estiver usando)\n    # lock.acquire()\n\n    local_contador = contador\n    time.sleep(0.01) # Simula algum trabalho\n    local_contador += 1\n    contador = local_contador\n\n    # Libere o lock aqui (se estiver usando)\n    # lock.release()\n\nthreads = []\nnum_threads = 10\n\nprint(f\"Valor inicial do contador: {contador}\")\n\nfor _ in range(num_threads):\n    thread = threading.Thread(target=incrementar)\n    threads.append(thread)\n    thread.start()\n\nfor thread in threads:\n    thread.join()\n\nprint(f\"Valor final do contador (sem/com lock): {contador}\")\nprint(f\"Valor esperado: {num_threads}\")\n\n# Para o teste, vamos verificar se o valor final é o esperado (com o lock funcionando)\n# O teste abaixo assume que o lock foi implementado corretamente na solution_code",
        "solution_code": "import threading\nimport time\n\ncontador = 0\nlock = threading.Lock() # Crie o lock\n\ndef incrementar():\n    global contador\n    # Use 'with lock:' para gerenciar o lock automaticamente\n    with lock:\n        local_contador = contador\n        # time.sleep(0.01) # Simula algum trabalho (pode remover ou manter, o lock protege)\n        local_contador += 1\n        contador = local_contador\n\nthreads = []\nnum_threads = 10\n\nprint(f\"Valor inicial do contador: {contador}\")\n\nfor _ in range(num_threads):\n    thread = threading.Thread(target=incrementar)\n    threads.append(thread)\n    thread.start()\n\nfor thread in threads:\n    thread.join()\n\nprint(f\"Valor final do contador (com lock): {contador}\")\nprint(f\"Valor esperado: {num_threads}\")",
        "test_code": "assert \"Valor inicial do contador: 0\" in output and f\"Valor esperado: 10\" in output and f\"Valor final do contador (com lock): 10\" in output",
        "level": "avançado"
    },
    {
        "id": "ex-multiprocessing-simples-1",
        "lesson_id": "concorrencia-paralelismo",
        "title": "Criando e Executando Múltiplos Processos",
        "description": "Crie dois processos, cada um executando uma função simples que imprime uma mensagem e espera por um curto período de tempo. Inicie ambos os processos e espere que eles terminem.",
        "difficulty": "Médio",
        "order": 5,
        "instructions": "Importe `multiprocessing` e `time`. Defina duas funções, `tarefa_proc1` e `tarefa_proc2`, que imprimem mensagens e usam `time.sleep()`. Crie duas instâncias de `multiprocessing.Process`, uma para cada função. Chame `start()` em ambos e `join()` em ambos.",
        "initial_code": "import multiprocessing\nimport time\nimport os # Para obter o PID do processo\n\ndef tarefa_proc1():\n    print(f\"Processo 1 (PID: {os.getpid()}): Iniciado\")\n    time.sleep(0.5)\n    print(f\"Processo 1 (PID: {os.getpid()}): Finalizado\")\n\ndef tarefa_proc2():\n    print(f\"Processo 2 (PID: {os.getpid()}): Iniciado\")\n    time.sleep(0.7)\n    print(f\"Processo 2 (PID: {os.getpid()}): Finalizado\")\n\n# Crie os processos para tarefa_proc1 e tarefa_proc2\n# processo1 = ...\n# processo2 = ...\n\nprint(f\"Processo principal (PID: {os.getpid()}): Iniciando processos\")\n\n# Inicie os processos\n# ...\n# ...\n\n# Espere os processos terminarem\n# ...\n# ...\n\nprint(f\"Processo principal (PID: {os.getpid()}): Todos os processos finalizados.\")",
        "solution_code": "import multiprocessing\nimport time\nimport os\n\ndef tarefa_proc1():\n    print(f\"Processo 1 (PID: {os.getpid()}): Iniciado\")\n    time.sleep(0.5)\n    print(f\"Processo 1 (PID: {os.getpid()}): Finalizado\")\n\ndef tarefa_proc2():\n    print(f\"Processo 2 (PID: {os.getpid()}): Iniciado\")\n    time.sleep(0.7)\n    print(f\"Processo 2 (PID: {os.getpid()}): Finalizado\")\n\n# Garante que o código só é executado quando o script é o processo principal\nif __name__ == '__main__':\n    # Crie os processos\n    processo1 = multiprocessing.Process(target=tarefa_proc1)\n    processo2 = multiprocessing.Process(target=tarefa_proc2)\n\n    print(f\"Processo principal (PID: {os.getpid()}): Iniciando processos\")\n\n    # Inicie os processos\n    processo1.start()\n    processo2.start()\n\n    # Espere os processos terminarem\n    processo1.join()\n    processo2.join()\n\n    print(f\"Processo principal (PID: {os.getpid()}): Todos os processos finalizados.\")",
        "test_code": "assert \"Processo principal (PID:\" in output and \"): Iniciando processos\" in output\nassert \"Processo 1 (PID:\" in output and \"): Iniciado\" in output\nassert \"Processo 2 (PID:\" in output and \"): Iniciado\" in output\nassert \"Processo 1 (PID:\" in output and \"): Finalizado\" in output\nassert \"Processo 2 (PID:\" in output and \"): Finalizado\" in output\nassert \"Processo principal (PID:\" in output and \"): Todos os processos finalizados.\" in output",
        "level": "avançado"
    },
    {
        "id": "ex-multiprocessing-queue-1",
        "lesson_id": "concorrencia-paralelismo",
        "title": "Comunicação entre Processos com Queue",
        "description": "Use `multiprocessing.Queue` para permitir a comunicação entre um processo produtor e um processo consumidor. O produtor deve colocar alguns itens na fila e o consumidor deve retirá-los e imprimi-los.",
        "difficulty": "Difícil",
        "order": 6,
        "instructions": "Importe `multiprocessing` e `time`. Crie uma `multiprocessing.Queue`. Defina uma função `produtor(queue)` que coloca itens na fila e um sinal de 'fim' (ex: `None`). Defina uma função `consumidor(queue)` que retira itens da fila até receber o sinal de 'fim'. Crie e inicie os processos produtor e consumidor, passando a fila. Espere ambos terminarem.",
        "initial_code": "import multiprocessing\nimport time\n\ndef produtor(queue):\n    print(\"Produtor: Iniciado\")\n    for i in range(5):\n        item = f\"Item {i}\"\n        queue.put(item)\n        print(f\"Produtor: Colocou '{item}' na fila\")\n        time.sleep(0.1)\n    queue.put(None) # Sinaliza o fim\n    print(\"Produtor: Finalizado\")\n\ndef consumidor(queue):\n    print(\"Consumidor: Iniciado\")\n    while True:\n        item = queue.get()\n        if item is None:\n            break\n        print(f\"Consumidor: Retirou '{item}' da fila\")\n        time.sleep(0.2)\n    print(\"Consumidor: Finalizado\")\n\n# Garante que o código só é executado quando o script é o processo principal\nif __name__ == '__main__':\n    # Crie a Queue\n    # fila = ...\n\n    # Crie os processos produtor e consumidor, passando a fila\n    # processo_produtor = ...\n    # processo_consumidor = ...\n\n    print(\"Principal: Iniciando processos Produtor e Consumidor\")\n\n    # Inicie os processos\n    # ...\n    # ...\n\n    # Espere os processos terminarem\n# ...\n# ...\n\n    print(\"Principal: Todos os processos de comunicação finalizados.\")",
        "solution_code": "import multiprocessing\nimport time\n\ndef produtor(queue):\n    print(\"Produtor: Iniciado\")\n    for i in range(5):\n        item = f\"Item {i}\"\n        queue.put(item)\n        print(f\"Produtor: Colocou '{item}' na fila\")\n        time.sleep(0.1)\n    queue.put(None) # Sinaliza o fim\n    print(\"Produtor: Finalizado\")\n\ndef consumidor(queue):\n    print(\"Consumidor: Iniciado\")\n    while True:\n        item = queue.get()\n        if item is None:\n            break\n        print(f\"Consumidor: Retirou '{item}' da fila\")\n        time.sleep(0.2)\n    print(\"Consumidor: Finalizado\")\n\nif __name__ == '__main__':\n    # Crie a Queue\n    fila = multiprocessing.Queue()\n\n    # Crie os processos produtor e consumidor\n    processo_produtor = multiprocessing.Process(target=produtor, args=(fila,))\n    processo_consumidor = multiprocessing.Process(target=consumidor, args=(fila,))\n\n    print(\"Principal: Iniciando processos Produtor e Consumidor\")\n\n    # Inicie os processos\n    processo_produtor.start()\n    processo_consumidor.start()\n\n    # Espere os processos terminarem\n    processo_produtor.join()\n    processo_consumidor.join()\n\n    print(\"Principal: Todos os processos de comunicação finalizados.\")",
        "test_code": "assert \"Principal: Iniciando processos Produtor e Consumidor\" in output and \"Produtor: Iniciado\" in output and \"Consumidor: Iniciado\" in output and \"Produtor: Colocou 'Item 0' na fila\" in output and \"Consumidor: Retirou 'Item 0' da fila\" in output and \"Produtor: Colocou 'Item 4' na fila\" in output and \"Consumidor: Retirou 'Item 4' da fila\" in output and \"Produtor: Finalizado\" in output and \"Consumidor: Finalizado\" in output and \"Principal: Todos os processos de comunicação finalizados.\" in output",
        "level": "avançado"
    },
    {
        "id": "ex-asyncio-conceito-1",
        "lesson_id": "concorrencia-paralelismo",
        "title": "Programação Assíncrona (Conceitual)",
        "description": "Explique o conceito de programação assíncrona em Python e para quais tipos de tarefas ela é particularmente útil.",
        "difficulty": "Médio",
        "order": 7,
        "instructions": "Descreva o que significa 'assíncrono' no contexto de programação e por que é bom para I/O bound tasks. Use a função print() para sua resposta.",
        "initial_code": "# Explique Programação Assíncrona aqui\n# print(\"Programação assíncrona em Python permite...\")\n# print(\"É particularmente útil para tarefas como...\")",
        "solution_code": "print(\"Programação assíncrona em Python permite que um único thread de execução gerencie múltiplas operações que podem levar tempo (como I/O de rede ou disco) sem bloquear a execução do programa principal.\")\nprint(\"É particularmente útil para tarefas I/O-bound, onde o programa passa muito tempo esperando por dados externos. Em vez de ficar ocioso, o thread pode alternar para outra tarefa enquanto espera.\")",
        "test_code": "assert \"Programação assíncrona\" in output and (\"único thread\" in output or \"sem bloquear\" in output) and (\"I/O\" in output or \"rede\" in output or \"disco\" in output) and \"I/O-bound\" in output and (\"esperando\" in output or \"alternar\" in output)",
        "level": "avançado"
    },
    {
        "id": "ex-asyncio-simples-1",
        "lesson_id": "concorrencia-paralelismo",
        "title": "Usando asyncio, async/await para I/O Simulado",
        "description": "Crie duas corrotinas assíncronas usando `async def` que simulam uma operação de I/O demorada usando `asyncio.sleep()`. Use `await` para esperar a conclusão dessas operações dentro de uma função principal assíncrona. Execute a função principal usando `asyncio.run()`.",
        "difficulty": "Difícil",
        "order": 8,
        "instructions": "Importe `asyncio`. Defina duas corrotinas `tarefa_async1` e `tarefa_async2` com `async def`, usando `await asyncio.sleep()` dentro delas. Defina uma função principal `main` também com `async def` que chama e espera (`await`) as duas corrotinas. Use `asyncio.run(main())` para iniciar o loop de eventos e executar a função principal.",
        "initial_code": "import asyncio\n\nasync def tarefa_async1():\n    print(\"Tarefa Assíncrona 1: Iniciada\")\n    # Simule I/O demorado\n    # await asyncio.sleep(1)\n    print(\"Tarefa Assíncrona 1: Finalizada\")\n\nasync def tarefa_async2():\n    print(\"Tarefa Assíncrona 2: Iniciada\")\n    # Simule I/O demorado\n    # await asyncio.sleep(0.8)\n    print(\"Tarefa Assíncrona 2: Finalizada\")\n\nasync def main():\n    print(\"Principal Assíncrono: Iniciado\")\n    # Chame e espere as corrotinas\n    # await tarefa_async1()\n    # await tarefa_async2()\n    # Para executar concorrentemente (opcional, mas comum com asyncio):\n    # await asyncio.gather(tarefa_async1(), tarefa_async2())\n    print(\"Principal Assíncrono: Finalizado\")\n\n# Execute a função principal assíncrona\n# asyncio.run(main())",
        "solution_code": "import asyncio\n\nasync def tarefa_async1():\n    print(\"Tarefa Assíncrona 1: Iniciada\")\n    # Simule I/O demorado\n    await asyncio.sleep(0.5)\n    print(\"Tarefa Assíncrona 1: Finalizada\")\n\nasync def tarefa_async2():\n    print(\"Tarefa Assíncrona 2: Iniciada\")\n    # Simule I/O demorado\n    await asyncio.sleep(0.3)\n    print(\"Tarefa Assíncrona 2: Finalizada\")\n\nasync def main():\n    print(\"Principal Assíncrono: Iniciado\")\n    # Executa as corrotinas concorrentemente\n    await asyncio.gather(tarefa_async1(), tarefa_async2())\n    print(\"Principal Assíncrono: Finalizado\")\n\n# Execute a função principal assíncrona\nasyncio.run(main())",
        "test_code": "assert \"Principal Assíncrono: Iniciado\" in output and \"Tarefa Assíncrona 1: Iniciada\" in output and \"Tarefa Assíncrona 2: Iniciada\" in output and \"Tarefa Assíncrona 1: Finalizada\" in output and \"Tarefa Assíncrona 2: Finalizada\" in output and \"Principal Assíncrono: Finalizado\" in output",
        "level": "avançado"
    },
    {
        "id": "ex-gui-conceito-1",
        "lesson_id": "gui-tkinter-intro",
        "title": "O que é GUI e Bibliotecas Python (Conceitual)",
        "description": "Explique o que é uma Interface Gráfica do Usuário (GUI) e mencione brevemente três bibliotecas Python populares para criar GUIs.",
        "difficulty": "Fácil",
        "order": 1,
        "instructions": "Descreva o que é uma GUI e liste três bibliotecas comuns em Python para desenvolvê-las. Use a função print() para sua resposta.",
        "initial_code": "# Explique o que é GUI e liste bibliotecas aqui\n# print(\"Uma Interface Gráfica do Usuário (GUI) é...\")\n# print(\"Algumas bibliotecas GUI populares em Python são: ..., ..., ...\")",
        "solution_code": "print(\"Uma Interface Gráfica do Usuário (GUI) é um tipo de interface que permite aos usuários interagirem com programas de computador através de elementos visuais como janelas, ícones e menus, em vez de comandos de texto.\")\nprint(\"Algumas bibliotecas GUI populares em Python são: Tkinter, PyQt, Kivy.\")",
        "test_code": "assert \"Interface Gráfica do Usuário\" in output or \"GUI\" in output and (\"Tkinter\" in output or \"PyQt\" in output or \"Kivy\" in output)",
        "level": "avançado"
    },
    {
        "id": "ex-tkinter-janela-simples-1",
        "lesson_id": "gui-tkinter-intro",
        "title": "Criando uma Janela Principal Tkinter (Simulado)",
        "description": "Simule o código Python necessário para criar a janela principal de uma aplicação Tkinter com um título.",
        "difficulty": "Fácil",
        "order": 2,
        "instructions": "Importe `tkinter as tk`. Crie uma instância da classe `tk.Tk()`. Defina o título da janela usando o método `.title()`. Para o teste, imprima uma mensagem confirmando a criação simulada.",
        "initial_code": "import tkinter as tk\n\n# Crie a janela principal aqui (não precisa de mainloop para o teste)\n# root = tk.Tk()\n# root.title(\"Minha Janela\")\n\n# Imprima a mensagem de confirmação\nprint(\"Simulação: Janela principal Tkinter criada com título.\")",
        "solution_code": "import tkinter as tk\n\n# Simulação da criação da janela principal\n# root = tk.Tk()\n# root.title(\"Minha Janela Tkinter\")\n\nprint(\"Simulação: Janela principal Tkinter criada com título.\")",
        "test_code": "assert \"Simulação: Janela principal Tkinter criada com título.\" in output",
        "level": "avançado"
    },
    {
        "id": "ex-tkinter-label-1",
        "lesson_id": "gui-tkinter-intro",
        "title": "Adicionando um Label à Janela (Simulado)",
        "description": "Simule a criação de um widget `Label` com o texto \"Olá, Tkinter!\" e adicione-o a uma janela principal (simulada).",
        "difficulty": "Médio",
        "order": 3,
        "instructions": "Importe `tkinter as tk`. Crie a janela principal simulada. Crie uma instância de `tk.Label` passando a janela como primeiro argumento e o texto desejado no parâmetro `text`. Simule o posicionamento com `.pack()`. Imprima uma mensagem confirmando a criação e adição do Label.",
        "initial_code": "import tkinter as tk\n\n# Simulação da janela principal\n# root = tk.Tk()\n# root.title(\"Janela com Label\")\n\n# Crie o widget Label aqui\n# label_saudacao = tk.Label(root, text=\"Olá, Tkinter!\")\n\n# Adicione o Label à janela usando pack (simulado)\n# label_saudacao.pack()\n\n# Imprima a mensagem de confirmação\nprint(\"Simulação: Widget Label criado e adicionado à janela.\")",
        "solution_code": "import tkinter as tk\n\n# Simulação da janela principal\n# root = tk.Tk()\n# root.title(\"Janela com Label\")\n\n# Simulação da criação e adição do Label\n# label_saudacao = tk.Label(root, text=\"Olá, Tkinter!\")\n# label_saudacao.pack()\n\nprint(\"Simulação: Widget Label criado e adicionado à janela.\")",
        "test_code": "assert \"Simulação: Widget Label criado e adicionado à janela.\" in output",
        "level": "avançado"
    },
    {
        "id": "ex-tkinter-button-event-1",
        "lesson_id": "gui-tkinter-intro",
        "title": "Botão Tkinter com Ação (Simulado)",
        "description": "Simule a criação de um botão Tkinter com o texto \"Clique-me\" que, ao ser 'clicado' (simulado), executa uma função que imprime uma mensagem no console.",
        "difficulty": "Médio",
        "order": 4,
        "instructions": "Importe `tkinter as tk`. Defina uma função `ao_clicar()` que imprime \"Botão clicado!\". Crie a janela simulada. Crie um `tk.Button` passando a janela e o texto. Associe a função `ao_clicar` ao parâmetro `command` do botão. Simule o posicionamento com `.pack()`. Para o teste, chame a função `ao_clicar()` diretamente para simular o evento e imprima uma mensagem de confirmação.",
        "initial_code": "import tkinter as tk\n\ndef ao_clicar():\n    # Imprima a mensagem quando o botão for 'clicado'\n    print(\"Botão clicado!\")\n\n# Simulação da janela principal\n# root = tk.Tk()\n# root.title(\"Janela com Botão\")\n\n# Crie o widget Button aqui, associando ao_clicar ao command\n# botao_teste = tk.Button(root, text=\"Clique-me\", command=ao_clicar)\n\n# Adicione o botão à janela usando pack (simulado)\n# botao_teste.pack()\n\n# Simule o clique chamando a função diretamente para o teste\n# ao_clicar()\nprint(\"Simulação: Widget Button criado com comando associado.\")",
        "solution_code": "import tkinter as tk\n\ndef ao_clicar():\n    print(\"Botão clicado!\")\n\n# Simulação da janela principal e botão\n# root = tk.Tk()\n# root.title(\"Janela com Botão\")\n# botao_teste = tk.Button(root, text=\"Clique-me\", command=ao_clicar)\n# botao_teste.pack()\n\n# Simule o clique chamando a função diretamente para o teste automatizado\nao_clicar()\nprint(\"Simulação: Widget Button criado com comando associado.\")",
        "test_code": "assert \"Botão clicado!\" in output and \"Simulação: Widget Button criado com comando associado.\" in output",
        "level": "avançado"
    },
    {
        "id": "ex-tkinter-entry-1",
        "lesson_id": "gui-tkinter-intro",
        "title": "Adicionando um Campo de Entrada (Entry) (Simulado)",
        "description": "Simule a criação de um widget `Entry` (campo de texto) onde o usuário pode digitar algo e adicione-o a uma janela principal (simulada).",
        "difficulty": "Médio",
        "order": 5,
        "instructions": "Importe `tkinter as tk`. Crie a janela simulada. Crie uma instância de `tk.Entry` passando a janela. Simule o posicionamento com `.pack()`. Imprima uma mensagem confirmando a criação e adição do Entry.",
        "initial_code": "import tkinter as tk\n\n# Simulação da janela principal\n# root = tk.Tk()\n# root.title(\"Janela com Entry\")\n\n# Crie o widget Entry aqui\n# campo_texto = tk.Entry(root)\n\n# Adicione o Entry à janela usando pack (simulado)\n# campo_texto.pack()\n\n# Imprima a mensagem de confirmação\nprint(\"Simulação: Widget Entry criado e adicionado à janela.\")",
        "solution_code": "import tkinter as tk\n\n# Simulação da janela principal\n# root = tk.Tk()\n# root.title(\"Janela com Entry\")\n\n# Simulação da criação e adição do Entry\n# campo_texto = tk.Entry(root)\n# campo_texto.pack()\n\nprint(\"Simulação: Widget Entry criado e adicionado à janela.\")",
        "test_code": "assert \"Simulação: Widget Entry criado e adicionado à janela.\" in output",
        "level": "avançado"
    },
    {
        "id": "ex-tkinter-layout-pack-1",
        "lesson_id": "gui-tkinter-intro",
        "title": "Organizando Widgets com pack() (Simulado)",
        "description": "Simule a criação de três Labels com textos diferentes ('Primeiro', 'Segundo', 'Terceiro') e adicione-os a uma janela (simulada) usando o gerenciador de layout `pack()` para que apareçam um abaixo do outro.",
        "difficulty": "Médio",
        "order": 6,
        "instructions": "Importe `tkinter as tk`. Crie a janela simulada. Crie três `tk.Label`. Chame `.pack()` para cada Label. O `pack()` sem argumentos padrão os posiciona verticalmente. Imprima uma mensagem confirmando a simulação do layout.",
        "initial_code": "import tkinter as tk\n\n# Simulação da janela principal\n# root = tk.Tk()\n# root.title(\"Layout com Pack\")\n\n# Crie os três Labels\n# label1 = tk.Label(root, text=\"Primeiro\")\n# label2 = tk.Label(root, text=\"Segundo\")\n# label3 = tk.Label(root, text=\"Terceiro\")\n\n# Adicione os Labels à janela usando pack()\n# label1.pack()\n# label2.pack()\n# label3.pack()\n\n# Imprima a mensagem de confirmação\nprint(\"Simulação: Widgets organizados com pack() verticalmente.\")",
        "solution_code": "import tkinter as tk\n\n# Simulação da janela principal\n# root = tk.Tk()\n# root.title(\"Layout com Pack\")\n\n# Simulação da criação e adição dos Labels com pack()\n# label1 = tk.Label(root, text=\"Primeiro\")\n# label2 = tk.Label(root, text=\"Segundo\")\n# label3 = tk.Label(root, text=\"Terceiro\")\n# label1.pack()\n# label2.pack()\n# label3.pack()\n\nprint(\"Simulação: Widgets organizados com pack() verticalmente.\")",
        "test_code": "assert \"Simulação: Widgets organizados com pack() verticalmente.\" in output",
        "level": "avançado"
    },
    {
        "id": "ex-tkinter-layout-grid-1",
        "lesson_id": "gui-tkinter-intro",
        "title": "Organizando Widgets com grid() (Simulado)",
        "description": "Simule a criação de dois Labels ('Nome:', 'Idade:') e dois Entrys (campos de texto) e organize-os em uma grade 2x2 usando o gerenciador de layout `grid()`.",
        "difficulty": "Médio",
        "order": 7,
        "instructions": "Importe `tkinter as tk`. Crie a janela simulada. Crie os dois Labels e os dois Entrys. Use o método `.grid()` para cada widget, especificando as opções `row` (linha) e `column` (coluna) para posicioná-los na grade. Imprima uma mensagem confirmando a simulação do layout.",
        "initial_code": "import tkinter as tk\n\n# Simulação da janela principal\n# root = tk.Tk()\n# root.title(\"Layout com Grid\")\n\n# Crie os Labels e Entrys\n# label_nome = tk.Label(root, text=\"Nome:\")\n# entry_nome = tk.Entry(root)\n# label_idade = tk.Label(root, text=\"Idade:\")\n# entry_idade = tk.Entry(root)\n\n# Organize os widgets na grade usando grid()\n# label_nome.grid(row=0, column=0)\n# entry_nome.grid(row=0, column=1)\n# label_idade.grid(row=1, column=0)\n# entry_idade.grid(row=1, column=1)\n\n# Imprima a mensagem de confirmação\nprint(\"Simulação: Widgets organizados com grid() em 2x2.\")",
        "solution_code": "import tkinter as tk\n\n# Simulação da janela principal\n# root = tk.Tk()\n# root.title(\"Layout com Grid\")\n\n# Simulação da criação e organização dos widgets com grid()\n# label_nome = tk.Label(root, text=\"Nome:\")\n# entry_nome = tk.Entry(root)\n# label_idade = tk.Label(root, text=\"Idade:\")\n# entry_idade = tk.Entry(root)\n\n# label_nome.grid(row=0, column=0)\n# entry_nome.grid(row=0, column=1)\n# label_idade.grid(row=1, column=0)\n# entry_idade.grid(row=1, column=1)\n\nprint(\"Simulação: Widgets organizados com grid() em 2x2.\")",
        "test_code": "assert \"Simulação: Widgets organizados com grid() em 2x2.\" in output",
        "level": "avançado"
    },
    {
        "id": "ex-tkinter-app-simples-interativa-1",
        "lesson_id": "gui-tkinter-intro",
        "title": "Aplicação GUI Simples: Saudação Personalizada (Simulado)",
        "description": "Simule a criação de uma aplicação Tkinter simples com um campo `Entry` para o nome, um `Button` e um `Label` para exibir a saudação. Ao clicar no botão, a aplicação deve obter o texto do `Entry` e atualizar o texto do `Label` para \"Olá, [Nome Digitado]!\".",
        "difficulty": "Difícil",
        "order": 8,
        "instructions": "Importe `tkinter as tk`. Defina uma função `mostrar_saudacao(entry_widget, label_widget)` que obtém o texto do `entry_widget` usando `.get()`, formata a saudação e atualiza o `label_widget` usando `.config(text=...)`. Crie a janela simulada, o Label (inicialmente vazio ou com texto padrão), o Entry e o Button. Associe a função `mostrar_saudacao` ao `command` do Button, passando os widgets relevantes. Simule o layout e a chamada da função de callback para o teste.",
        "initial_code": "import tkinter as tk\n\n# Função que será chamada pelo botão\ndef mostrar_saudacao(entry_widget, label_widget):\n    # Obtenha o texto do Entry\n    # nome = ...\n    # Crie a mensagem de saudação\n    # mensagem = f\"Olá, {nome}!\"\n    # Atualize o texto do Label\n    # label_widget.config(text=mensagem)\n    print(f\"Simulando: Obteve nome '{entry_widget.get()}' e atualizou Label.\")\n\n# Simulação da janela principal\n# root = tk.Tk()\n# root.title(\"Saudação\")\n\n# Crie os widgets\n# label_saudacao = tk.Label(root, text=\"Digite seu nome:\")\n# entry_nome = tk.Entry(root)\n# botao_saudar = tk.Button(root, text=\"Saudar\", command=lambda: mostrar_saudacao(entry_nome, label_saudacao))\n# label_resultado = tk.Label(root, text=\"\") # Label para mostrar o resultado\n\n# Organize os widgets com pack ou grid (simulado)\n# label_saudacao.pack()\n# entry_nome.pack()\n# botao_saudar.pack()\n# label_resultado.pack()\n\n# Simule a entrada do usuário e o clique do botão para o teste\n# entry_nome.insert(0, \"Visitante\") # Simula digitação\n# mostrar_saudacao(entry_nome, label_resultado) # Simula clique\nprint(\"Simulação: Aplicação GUI de saudação configurada.\")",
        "solution_code": "import tkinter as tk\n\n# Função que será chamada pelo botão\ndef mostrar_saudacao(entry_widget, label_widget):\n    nome = entry_widget.get()\n    mensagem = f\"Olá, {nome}!\"\n    label_widget.config(text=mensagem)\n    print(f\"Simulando: Obteve nome '{nome}' e atualizou Label para '{mensagem}'.\")\n\n# Simulação da janela principal e widgets\n# root = tk.Tk()\n# root.title(\"Saudação\")\n# label_saudacao_prompt = tk.Label(root, text=\"Digite seu nome:\")\n# entry_nome = tk.Entry(root)\n# label_resultado = tk.Label(root, text=\"\") # Label para mostrar o resultado\n# botao_saudar = tk.Button(root, text=\"Saudar\", command=lambda: mostrar_saudacao(entry_nome, label_resultado))\n\n# Simulação do layout (usando pack)\n# label_saudacao_prompt.pack()\n# entry_nome.pack()\n# botao_saudar.pack()\n# label_resultado.pack()\n\n# Para o teste automatizado, vamos simular a interação\n# Precisamos de mock objects ou simular o comportamento dos widgets Tkinter\n\n# Simulação direta da lógica da função de callback para o teste:\nclass MockEntry:\n    def __init__(self, text):\n        self._text = text\n    def get(self):\n        return self._text\n\nclass MockLabel:\n    def __init__(self):\n        self._text = \"\"\n    def config(self, text):\n        self._text = text\n        print(f\"MockLabel atualizado para: {self._text}\")\n\nmock_entry = MockEntry(\"Mundo\")\nmock_label = MockLabel()\n\nmostrar_saudacao(mock_entry, mock_label)\n\nprint(\"Simulação: Aplicação GUI de saudação configurada e callback testado.\")",
        "test_code": "assert \"Simulando: Obteve nome 'Mundo' e atualizou Label para 'Olá, Mundo!'.\" in output and \"MockLabel atualizado para: Olá, Mundo!\" in output and \"Simulação: Aplicação GUI de saudação configurada e callback testado.\" in output",
        "level": "avançado"
    },
    {
        "id": "ex-especializacao-conceito-1",
        "lesson_id": "topicos-especiais-python",
        "title": "Áreas de Especialização em Python (Conceitual)",
        "description": "Mencione pelo menos quatro áreas de especialização onde a linguagem Python é amplamente utilizada, com base nos conceitos apresentados.",
        "difficulty": "Fácil",
        "order": 1,
        "instructions": "Liste quatro áreas de especialização onde Python é popular. Use a função print() para sua resposta.",
        "initial_code": "# Liste quatro áreas de especialização onde Python é popular aqui\n# print(\"- ...\")\n# print(\"- ...\")\n# print(\"- ...\")\n# print(\"- ...\")",
        "solution_code": "print(\"- Desenvolvimento Web (com frameworks como Django, Flask)\")\nprint(\"- Ciência de Dados e Machine Learning (com bibliotecas como NumPy, Pandas, Scikit-learn)\")\nprint(\"- Automação e DevOps\")\nprint(\"- Segurança Cibernética\")\nprint(\"- Desenvolvimento de Jogos (com bibliotecas como Pygame)\")\nprint(\"- Computação Científica e Numérica\")\nprint(\"- Análise de Big Data\")",
        "test_code": "assert output.count('-') >= 4 and ('Web' in output or 'Flask' in output or 'Django' in output) and ('Ciência de Dados' in output or 'Machine Learning' in output or 'NumPy' in output or 'Pandas' in output) and ('Automação' in output or 'DevOps' in output) and ('Segurança Cibernética' in output or 'Segurança' in output) and ('Jogos' in output or 'Pygame' in output)",
        "level": "avançado"
    },
    {
        "id": "ex-automacao-devops-conceito-1",
        "lesson_id": "topicos-especiais-python",
        "title": "Python em Automação e DevOps (Conceitual)",
        "description": "Explique brevemente o papel do Python em Automação de Tarefas e no campo de DevOps. Mencione um tipo de tarefa que Python pode automatizar.",
        "difficulty": "Fácil",
        "order": 2,
        "instructions": "Descreva o uso de Python em Automação/DevOps e dê um exemplo de automação. Use a função print() para sua resposta.",
        "initial_code": "# Explique o papel de Python em Automação/DevOps aqui\n# print(\"Em Automação e DevOps, Python é usado para...\")\n# print(\"Um exemplo de tarefa que Python pode automatizar é...\")",
        "solution_code": "print(\"Em Automação e DevOps, Python é usado para escrever scripts que automatizam tarefas repetitivas, gerenciar infraestrutura, orquestrar fluxos de trabalho e integrar diferentes ferramentas.\")\nprint(\"Um exemplo de tarefa que Python pode automatizar é a criação e gerenciamento de arquivos e diretórios, a execução remota de comandos em servidores ou a automação de testes.\")",
        "test_code": "assert (\"Automação\" in output or \"automatizar\") and (\"DevOps\" in output or \"infraestrutura\" in output or \"orquestrar\" in output) and (\"arquivos\" in output or \"diretórios\" in output or \"servidores\" in output or \"testes\" in output)",
        "level": "avançado"
    },
    {
        "id": "ex-seguranca-cibernetica-conceito-1",
        "lesson_id": "topicos-especiais-python",
        "title": "Python em Segurança Cibernética (Conceitual)",
        "description": "Mencione como Python é aplicado na área de Segurança Cibernética. Dê um exemplo de uma ferramenta ou técnica que pode ser implementada com Python para segurança.",
        "difficulty": "Médio",
        "order": 3,
        "instructions": "Descreva o uso de Python em Segurança Cibernética e dê um exemplo. Use a função print() para sua resposta.",
        "initial_code": "# Explique o uso de Python em Segurança Cibernética aqui\n# print(\"Python é aplicado em Segurança Cibernética para...\")\n# print(\"Um exemplo é a criação de ferramentas para...\")",
        "solution_code": "print(\"Python é aplicado em Segurança Cibernética para análise de malware, testes de penetração (pentesting), desenvolvimento de ferramentas de segurança, automação de tarefas de resposta a incidentes e análise forense.\")\nprint(\"Um exemplo é a criação de scripts para varredura de portas de rede ou para analisar logs de segurança.\")",
        "test_code": "assert (\"Segurança Cibernética\" in output or \"Segurança\") and (\"análise de malware\" in output or \"testes de penetração\" in output or \"ferramentas de segurança\" in output or \"resposta a incidentes\" in output or \"análise forense\" in output) and (\"varredura de portas\" in output or \"analisar logs\" in output)",
        "level": "avançado"
    },
    {
        "id": "ex-jogos-pygame-conceito-1",
        "lesson_id": "topicos-especiais-python",
        "title": "Introdução a Desenvolvimento de Jogos com Pygame (Conceitual)",
        "description": "O que é Pygame e qual seu propósito no desenvolvimento de jogos com Python? Mencione um elemento básico que Pygame ajuda a gerenciar.",
        "difficulty": "Fácil",
        "order": 4,
        "instructions": "Descreva Pygame e seu propósito, e mencione um elemento básico de jogo que ele lida. Use a função print() para sua resposta.",
        "initial_code": "# Explique Pygame aqui\n# print(\"Pygame é...\")\n# print(\"Seu propósito é...\")\n# print(\"Ajuda a gerenciar elementos como...\")",
        "solution_code": "print(\"Pygame é uma biblioteca de módulos Python projetada para escrever jogos de vídeo. Ela adiciona funcionalidade em cima da biblioteca SDL (Simple DirectMedia Layer).\")\nprint(\"Seu propósito é permitir que desenvolvedores Python criem jogos e multimídia de forma mais fácil, abstraindo detalhes de baixo nível.\")\nprint(\"Ajuda a gerenciar elementos como gráficos (desenho na tela), som, entrada do usuário (teclado, mouse) e detecção de colisões.\")",
        "test_code": "assert \"Pygame\" in output and (\"jogos de vídeo\" in output or \"criar jogos\" in output) and (\"gráficos\" in output or \"som\" in output or \"entrada do usuário\" in output or \"colisões\" in output)",
        "level": "avançado"
    },
    {
        "id": "ex-computacao-cientifica-conceito-1",
        "lesson_id": "topicos-especiais-python",
        "title": "Python em Computação Científica (Conceitual)",
        "description": "Mencione o papel do Python em Computação Científica e Numérica. Cite duas bibliotecas Python populares usadas nesta área.",
        "difficulty": "Fácil",
        "order": 5,
        "instructions": "Descreva o uso de Python em Computação Científica e liste duas bibliotecas. Use a função print() para sua resposta.",
        "initial_code": "# Explique o uso de Python em Computação Científica aqui\n# print(\"Em Computação Científica, Python é usado para...\")\n# print(\"Duas bibliotecas populares são: ... e ...\")",
        "solution_code": "print(\"Em Computação Científica e Numérica, Python é usado para realizar cálculos complexos, simulações, modelagem de dados e análise estatística.\")\nprint(\"Duas bibliotecas populares são: NumPy (para arrays e operações numéricas eficientes) e SciPy (para computação científica e técnica, incluindo otimização, álgebra linear, integração, etc.).\")",
        "test_code": "assert (\"Computação Científica\" in output or \"Numérica\") and (\"cálculos complexos\" in output or \"simulações\" in output or \"modelagem de dados\" in output or \"análise estatística\" in output) and (\"NumPy\" in output) and (\"SciPy\" in output)",
        "level": "avançado"
    },
    {
        "id": "ex-big-data-pyspark-conceito-1",
        "lesson_id": "topicos-especiais-python",
        "title": "Introdução a Análise de Big Data com PySpark (Conceitual)",
        "description": "O que é PySpark e qual seu papel na análise de Big Data com Python?",
        "difficulty": "Médio",
        "order": 6,
        "instructions": "Descreva PySpark e como ele se relaciona com Big Data em Python. Use a função print() para sua resposta.",
        "initial_code": "# Explique PySpark aqui\n# print(\"PySpark é...\")\n# print(\"Seu papel na análise de Big Data com Python é...\")",
        "solution_code": "print(\"PySpark é a API Python para Apache Spark, um poderoso motor de processamento unificado para análise de dados em larga escala.\")\nprint(\"Seu papel na análise de Big Data com Python é permitir que desenvolvedores Python escrevam aplicações para processar grandes volumes de dados de forma distribuída e eficiente, utilizando o poder do cluster Spark.\")",
        "test_code": "assert \"PySpark\" in output and \"Apache Spark\" in output and (\"Big Data\" in output or \"dados em larga escala\" in output or \"grandes volumes de dados\" in output) and (\"distribuída\" in output or \"cluster Spark\" in output)",
        "level": "avançado"
    },
    {
        "id": "ex-apis-restful-avancadas-conceito-1",
        "lesson_id": "topicos-especiais-python",
        "title": "Desenvolvimento de APIs RESTful Avançadas (Conceitual)",
        "description": "Além do Flask (microframework), mencione outro framework web Python popular e mais completo para o desenvolvimento de APIs RESTful avançadas. Qual a principal diferença conceitual entre ele e o Flask?",
        "difficulty": "Médio",
        "order": 7,
        "instructions": "Mencione um framework web Python mais completo que Flask (ex: Django, FastAPI). Explique a diferença conceitual (ex: 'baterias incluídas' vs minimalista). Use a função print() para sua resposta.",
        "initial_code": "# Mencione outro framework web Python e a diferença para Flask aqui\n# print(\"Outro framework web popular para APIs RESTful é...\")\n# print(\"A principal diferença conceitual para o Flask é que...\")",
        "solution_code": "print(\"Outro framework web popular para APIs RESTful avançadas é o Django Rest Framework (DRF), que se baseia no framework web Django, ou o FastAPI.\")\nprint(\"A principal diferença conceitual para o Flask é que frameworks como Django/DRF ou FastAPI são mais 'full-stack' ou 'batteries-included', oferecendo mais funcionalidades embutidas (ORM, autenticação, serialização, documentação automática) que o Flask não oferece por padrão, exigindo a adição de extensões.\")",
        "test_code": "assert (\"Django\" in output or \"FastAPI\" in output) and (\"APIs RESTful\" in output or \"APIs\") and (\"Flask\" in output) and (\"full-stack\" in output or \"batteries-included\" in output or \"funcionalidades embutidas\" in output or \"extensões\" in output)",
        "level": "avançado"
    },
    {
        "id": "ex-futuro-aprofundamento-conceito-1",
        "lesson_id": "topicos-especiais-python",
        "title": "Identificando Áreas de Interesse (Conceitual)",
        "description": "Das áreas de especialização apresentadas, qual delas mais despertou seu interesse para um possível aprofundamento futuro? Por quê?",
        "difficulty": "Fácil",
        "order": 8,
        "instructions": "Escolha uma área que lhe interesse e explique brevemente o motivo. Use a função print() para sua resposta.",
        "initial_code": "# Qual área lhe interessa mais e por quê?\n# print(\"A área que mais me interessou é...\")\n# print(\"Porque...\")",
        "solution_code": "print(\"A área que mais me interessou é [Sua Área de Interesse].\")\nprint(\"Porque [Sua Justificativa - ex: gosto de resolver problemas complexos, me interesso por segurança, quero criar jogos, etc.].\")",
        "test_code": "assert \"A área que mais me interessou é\" in output and \"Porque\" in output",
        "level": "avançado"
    },
    {
        "id": "ex-iterators-iterables-conceito-1",
        "lesson_id": "python-avancado-generators",
        "title": "Iteradores e Iteráveis (Conceitual)",
        "description": "Explique a diferença entre um objeto iterável e um objeto iterador em Python. Como você obtém um iterador a partir de um iterável?",
        "difficulty": "Fácil",
        "order": 1,
        "instructions": "Descreva a diferença entre iterável e iterador. Mencione a função Python usada para obter um iterador. Use a função print() para sua resposta.",
        "initial_code": "# Explique iteráveis e iteradores aqui\n# print(\"Um iterável é...\")\n# print(\"Um iterador é...\")\n# print(\"Você obtém um iterador de um iterável usando a função...\")",
        "solution_code": "print(\"Um iterável é um objeto que pode ser percorrido (iterado), como listas, tuplas, strings, dicionários. Ele possui o método __iter__().\")\nprint(\"Um iterador é um objeto que representa um fluxo de dados e mantém o estado da iteração. Ele possui os métodos __iter__() e __next__().\")\nprint(\"Você obtém um iterador de um iterável usando a função iter().\")",
        "test_code": "assert \"iterável\" in output.lower() and \"__iter__()\" in output and \"iterador\" in output.lower() and \"__next__()\" in output and \"iter()\" in output",
        "level": "avançado"
    },
    {
        "id": "ex-generators-yield-conceito-1",
        "lesson_id": "python-avancado-generators",
        "title": "Geradores e a Palavra-chave yield (Conceitual)",
        "description": "Explique o que é um gerador em Python e qual o papel da palavra-chave `yield` na criação de funções geradoras.",
        "difficulty": "Fácil",
        "order": 2,
        "instructions": "Descreva o que é um gerador e a função de `yield`. Use a função print() para sua resposta.",
        "initial_code": "# Explique geradores e yield aqui\n# print(\"Um gerador em Python é...\")\n# print(\"A palavra-chave yield é usada para...\")",
        "solution_code": "print(\"Um gerador em Python é uma função que retorna um iterador. Ele produz valores sob demanda à medida que é iterado, em vez de construir uma lista completa na memória.\")\nprint(\"A palavra-chave yield é usada em uma função para indicar que ela é um gerador. Quando yield é encontrada, o estado da função é salvo e o valor é retornado. Na próxima iteração, a execução continua de onde parou.\")",
        "test_code": "assert \"gerador\" in output.lower() and \"iterador\" in output.lower() and (\"sob demanda\" in output.lower() or \"lazy\") and \"yield\" in output and (\"estado da função é salvo\" in output or \"continua de onde parou\" in output)",
        "level": "avançado"
    },
    {
        "id": "ex-generators-funcao-simples-1",
        "lesson_id": "python-avancado-generators",
        "title": "Criando uma Função Geradora Simples",
        "description": "Crie uma função geradora chamada `contador_simples` que gere os números de 1 a 3 usando a palavra-chave `yield`. Em seguida, itere sobre o gerador e imprima cada número.",
        "difficulty": "Médio",
        "order": 3,
        "instructions": "Defina a função `contador_simples` com `yield` para 1, 2 e 3. Chame a função para obter o objeto gerador. Use um loop `for` para iterar sobre o gerador e imprimir os valores.",
        "initial_code": "# Crie a função geradora contador_simples aqui\n# def contador_simples():\n#     yield 1\n#     yield 2\n#     yield 3\n\n# Obtenha o objeto gerador\n# meu_gerador = contador_simples()\n\n# Itere sobre o gerador e imprima os números\n# print(\"Números gerados:\")\n# for numero in meu_gerador:\n#     print(numero)",
        "solution_code": "def contador_simples():\n    yield 1\n    yield 2\n    yield 3\n\nmeu_gerador = contador_simples()\n\nprint(\"Números gerados:\")\nfor numero in meu_gerador:\n    print(numero)",
        "test_code": "expected_output = \"Números gerados:\\n1\\n2\\n3\"\nassert output.strip() == expected_output",
        "level": "avançado"
    },
    {
        "id": "ex-generators-expressao-simples-1",
        "lesson_id": "python-avancado-generators",
        "title": "Criando uma Expressão Geradora",
        "description": "Crie uma expressão geradora que produza o quadrado dos números de 1 a 5. Em seguida, itere sobre a expressão geradora e imprima cada quadrado.",
        "difficulty": "Médio",
        "order": 4,
        "instructions": "Use a sintaxe de expressão geradora `(expressao for item in iteravel)`. Itere sobre a expressão geradora e imprima os valores.",
        "initial_code": "# Crie a expressão geradora aqui\n# gerador_quadrados = (...)\n\n# Itere sobre a expressão geradora e imprima os quadrados\n# print(\"Quadrados gerados:\")\n# for quadrado in gerador_quadrados:\n#     print(quadrado)",
        "solution_code": "# Cria a expressão geradora\ngerador_quadrados = (x**2 for x in range(1, 6))\n\nprint(\"Quadrados gerados:\")\nfor quadrado in gerador_quadrados:\n    print(quadrado)",
        "test_code": "expected_output = \"Quadrados gerados:\\n1\\n4\\n9\\n16\\n25\"\nassert output.strip() == expected_output",
        "level": "avançado"
    },
    {
        "id": "ex-generators-vs-listas-conceito-1",
        "lesson_id": "python-avancado-generators",
        "title": "Geradores vs Listas (Uso de Memória) (Conceitual)",
        "description": "Em termos de uso de memória, qual a principal vantagem de usar um gerador em comparação com a criação de uma lista completa para processar uma grande sequência de dados?",
        "difficulty": "Fácil",
        "order": 5,
        "instructions": "Compare o uso de memória de geradores e listas para grandes conjuntos de dados. Use a função print() para sua resposta.",
        "initial_code": "# Compare o uso de memória de geradores e listas aqui\n# print(\"A principal vantagem de geradores sobre listas para grandes sequências é...\")",
        "solution_code": "print(\"A principal vantagem de geradores sobre listas para grandes sequências é que geradores produzem valores um por um sob demanda (lazy evaluation), mantendo apenas o estado atual na memória. Listas, por outro lado, constroem e armazenam todos os elementos na memória de uma vez, o que pode consumir uma grande quantidade de RAM para grandes conjuntos de dados.\")",
        "test_code": "assert \"geradores\" in output.lower() and \"listas\" in output.lower() and (\"memória\" in output or \"RAM\") and (\"sob demanda\" in output.lower() or \"lazy evaluation\") and (\"um por um\" in output or \"todos os elementos\" in output)",
        "level": "avançado"
    },
    {
        "id": "ex-generators-arquivos-grandes-conceito-1",
        "lesson_id": "python-avancado-generators",
        "title": "Geradores para Leitura de Arquivos Grandes (Conceitual)",
        "description": "Explique como uma função geradora pode ser útil para ler e processar um arquivo de texto muito grande, linha por linha, sem carregar o arquivo inteiro na memória.",
        "difficulty": "Médio",
        "order": 6,
        "instructions": "Descreva o problema de carregar arquivos grandes e como um gerador resolve isso lendo linha por linha. Use a função print() para sua resposta.",
        "initial_code": "# Explique o uso de geradores para arquivos grandes aqui\n# print(\"Ao ler arquivos muito grandes...\")\n# print(\"Uma função geradora pode ajudar porque...\")",
        "solution_code": "print(\"Ao ler arquivos muito grandes, carregar todo o conteúdo na memória pode esgotar os recursos do sistema.\")\nprint(\"Uma função geradora pode ajudar porque pode ler e yield uma linha do arquivo por vez, processando cada linha sem precisar manter o arquivo inteiro na memória simultaneamente. Isso permite lidar com arquivos de qualquer tamanho, limitado apenas pelo espaço em disco para o arquivo em si.\")",
        "test_code": "assert (\"arquivos muito grandes\" in output or \"arquivo grande\") and (\"memória\" in output or \"RAM\") and \"geradora\" in output.lower() and (\"linha por linha\" in output or \"uma linha por vez\") and (\"sem precisar manter\" in output or \"sem carregar o arquivo inteiro\")",
        "level": "avançado"
    },
    {
        "id": "ex-arvore-binaria-estrutura-1",
        "lesson_id": "estruturas-algoritmos-avancados-impl",
        "title": "Estrutura Básica de Nó de Árvore Binária",
        "description": "Crie uma classe `NoArvore` para representar um nó em uma árvore binária. Cada nó deve ter um `valor` e referências para seus filhos `esquerda` e `direita` (inicialmente `None`). Crie uma pequena árvore de exemplo com uma raiz e dois filhos.",
        "difficulty": "Médio",
        "order": 1,
        "instructions": "Defina a classe `NoArvore` com o método `__init__(self, valor)`. Crie uma instância para a raiz e duas instâncias para os filhos, conectando-os à raiz. Imprima os valores da raiz e de seus filhos.",
        "initial_code": "class NoArvore:\n    def __init__(self, valor):\n        self.valor = valor\n        self.esquerda = None\n        self.direita = None\n\n# Crie a raiz da árvore\n# raiz = NoArvore(10)\n\n# Crie os filhos esquerdo e direito e conecte-os à raiz\n# raiz.esquerda = NoArvore(5)\n# raiz.direita = NoArvore(15)\n\n# Imprima os valores (simulado para teste)\n# print(f\"Raiz: {raiz.valor}\")\n# print(f\"Filho Esquerdo: {raiz.esquerda.valor}\")\n# print(f\"Filho Direito: {raiz.direita.valor}\")",
        "solution_code": "class NoArvore:\n    def __init__(self, valor):\n        self.valor = valor\n        self.esquerda = None\n        self.direita = None\n\n# Crie a raiz da árvore\nraiz = NoArvore(10)\n\n# Crie os filhos esquerdo e direito e conecte-os à raiz\nraiz.esquerda = NoArvore(5)\nraiz.direita = NoArvore(15)\n\n# Imprima os valores\nprint(f\"Raiz: {raiz.valor}\")\nprint(f\"Filho Esquerdo: {raiz.esquerda.valor}\")\nprint(f\"Filho Direito: {raiz.direita.valor}\")",
        "test_code": "assert \"Raiz: 10\" in output and \"Filho Esquerdo: 5\" in output and \"Filho Direito: 15\" in output",
        "level": "avançado"
    },
    {
        "id": "ex-arvore-binaria-inorder-1",
        "lesson_id": "estruturas-algoritmos-avancados-impl",
        "title": "Percurso In-order em Árvore Binária",
        "description": "Implemente uma função recursiva `percurso_in_order(no)` que percorra uma árvore binária na ordem In-order (Esquerda, Raiz, Direita) e imprima os valores dos nós.",
        "difficulty": "Médio",
        "order": 2,
        "instructions": "Use a classe `NoArvore` do exercício anterior. A função deve verificar se o nó atual não é `None`. Se não for, chame recursivamente para o filho esquerdo, imprima o valor do nó atual e chame recursivamente para o filho direito. Use `print(no.valor, end=' ')` para imprimir na mesma linha.",
        "initial_code": "class NoArvore:\n    def __init__(self, valor):\n        self.valor = valor\n        self.esquerda = None\n        self.direita = None\n\n# Criação da árvore de exemplo:\nraiz = NoArvore(20)\nraiz.esquerda = NoArvore(10)\nraiz.direita = NoArvore(30)\nraiz.esquerda.esquerda = NoArvore(5)\nraiz.esquerda.direita = NoArvore(15)\nraiz.direita.esquerda = NoArvore(25)\nraiz.direita.direita = NoArvore(35)\n\ndef percurso_in_order(no):\n    # Implemente o percurso in-order aqui\n    pass\n\nprint(\"Percurso In-Order:\")\n# percurso_in_order(raiz)\n# print() # Adiciona uma nova linha no final",
        "solution_code": "class NoArvore:\n    def __init__(self, valor):\n        self.valor = valor\n        self.esquerda = None\n        self.direita = None\n\n# Criação da árvore de exemplo:\nraiz = NoArvore(20)\nraiz.esquerda = NoArvore(10)\nraiz.direita = NoArvore(30)\nraiz.esquerda.esquerda = NoArvore(5)\nraiz.esquerda.direita = NoArvore(15)\nraiz.direita.esquerda = NoArvore(25)\nraiz.direita.direita = NoArvore(35)\n\ndef percurso_in_order(no):\n    if no:\n        percurso_in_order(no.esquerda)\n        print(no.valor, end=' ')\n        percurso_in_order(no.direita)\n\nprint(\"Percurso In-Order:\")\npercurso_in_order(raiz)\nprint()",
        "test_code": "assert \"Percurso In-Order:\" in output and \"5 10 15 20 25 30 35\" in output.strip()",
        "level": "avançado"
    },
    {
        "id": "ex-arvore-binaria-preorder-1",
        "lesson_id": "estruturas-algoritmos-avancados-impl",
        "title": "Percurso Pre-order em Árvore Binária",
        "description": "Implemente uma função recursiva `percurso_pre_order(no)` que percorra uma árvore binária na ordem Pre-order (Raiz, Esquerda, Direita) e imprima os valores dos nós.",
        "difficulty": "Médio",
        "order": 3,
        "instructions": "Use a classe `NoArvore`. A função deve verificar se o nó atual não é `None`. Se não for, imprima o valor do nó atual, chame recursivamente para o filho esquerdo e chame recursivamente para o filho direito. Use `print(no.valor, end=' ')`.",
        "initial_code": "class NoArvore:\n    def __init__(self, valor):\n        self.valor = valor\n        self.esquerda = None\n        self.direita = None\n\n# Criação da árvore de exemplo:\nraiz = NoArvore(20)\nraiz.esquerda = NoArvore(10)\nraiz.direita = NoArvore(30)\nraiz.esquerda.esquerda = NoArvore(5)\nraiz.esquerda.direita = NoArvore(15)\nraiz.direita.esquerda = NoArvore(25)\nraiz.direita.direita = NoArvore(35)\n\ndef percurso_pre_order(no):\n    # Implemente o percurso pre-order aqui\n    pass\n\nprint(\"Percurso Pre-Order:\")\n# percurso_pre_order(raiz)\n# print()",
        "solution_code": "class NoArvore:\n    def __init__(self, valor):\n        self.valor = valor\n        self.esquerda = None\n        self.direita = None\n\n# Criação da árvore de exemplo:\nraiz = NoArvore(20)\nraiz.esquerda = NoArvore(10)\nraiz.direita = NoArvore(30)\nraiz.esquerda.esquerda = NoArvore(5)\nraiz.esquerda.direita = NoArvore(15)\nraiz.direita.esquerda = NoArvore(25)\nraiz.direita.direita = NoArvore(35)\n\ndef percurso_pre_order(no):\n    if no:\n        print(no.valor, end=' ')\n        percurso_pre_order(no.esquerda)\n        percurso_pre_order(no.direita)\n\nprint(\"Percurso Pre-Order:\")\npercurso_pre_order(raiz)\nprint()",
        "test_code": "assert \"Percurso Pre-Order:\" in output and \"20 10 5 15 30 25 35\" in output.strip()",
        "level": "avançado"
    },
    {
        "id": "ex-arvore-binaria-postorder-1",
        "lesson_id": "estruturas-algoritmos-avancados-impl",
        "title": "Percurso Post-order em Árvore Binária",
        "description": "Implemente uma função recursiva `percurso_post_order(no)` que percorra uma árvore binária na ordem Post-order (Esquerda, Direita, Raiz) e imprima os valores dos nós.",
        "difficulty": "Médio",
        "order": 4,
        "instructions": "Use a classe `NoArvore`. A função deve verificar se o nó atual não é `None`. Se não for, chame recursivamente para o filho esquerdo, chame recursivamente para o filho direito e, por fim, imprima o valor do nó atual. Use `print(no.valor, end=' ')`.",
        "initial_code": "class NoArvore:\n    def __init__(self, valor):\n        self.valor = valor\n        self.esquerda = None\n        self.direita = None\n\n# Criação da árvore de exemplo:\nraiz = NoArvore(20)\nraiz.esquerda = NoArvore(10)\nraiz.direita = NoArvore(30)\nraiz.esquerda.esquerda = NoArvore(5)\nraiz.esquerda.direita = NoArvore(15)\nraiz.direita.esquerda = NoArvore(25)\nraiz.direita.direita = NoArvore(35)\n\ndef percurso_post_order(no):\n    # Implemente o percurso post-order aqui\n    pass\n\nprint(\"Percurso Post-Order:\")\n# percurso_post_order(raiz)\n# print()",
        "solution_code": "class NoArvore:\n    def __init__(self, valor):\n        self.valor = valor\n        self.esquerda = None\n        self.direita = None\n\n# Criação da árvore de exemplo:\nraiz = NoArvore(20)\nraiz.esquerda = NoArvore(10)\nraiz.direita = NoArvore(30)\nraiz.esquerda.esquerda = NoArvore(5)\nraiz.esquerda.direita = NoArvore(15)\nraiz.direita.esquerda = NoArvore(25)\nraiz.direita.direita = NoArvore(35)\n\ndef percurso_post_order(no):\n    if no:\n        percurso_post_order(no.esquerda)\n        percurso_post_order(no.direita)\n        print(no.valor, end=' ')\n\nprint(\"Percurso Post-Order:\")\npercurso_post_order(raiz)\nprint()",
        "test_code": "assert \"Percurso Post-Order:\" in output and \"5 15 10 25 35 30 20\" in output.strip()",
        "level": "avançado"
    },
    {
        "id": "ex-grafos-representacao-lista-adj-1",
        "lesson_id": "estruturas-algoritmos-avancados-impl",
        "title": "Representação de Grafo: Lista de Adjacência",
        "description": "Represente o seguinte grafo não direcionado usando uma lista de adjacência em um dicionário Python: Nós: A, B, C, D. Arestas: A-B, A-C, B-D, C-D.",
        "difficulty": "Fácil",
        "order": 5,
        "instructions": "Crie um dicionário onde as chaves são os nós e os valores são listas contendo os nós adjacentes. Para um grafo não direcionado, a aresta A-B significa que B está na lista de adjacência de A, e A está na lista de adjacência de B. Imprima o dicionário.",
        "initial_code": "# Represente o grafo usando um dicionário (lista de adjacência) aqui\n# grafo = {\n#     'A': [...],\n#     'B': [...],\n#     'C': [...],\n#     'D': [...]\n# }\n\n# Imprima o grafo\n# print(grafo)",
        "solution_code": "# Representa o grafo usando um dicionário (lista de adjacência)\ngrafo = {\n    'A': ['B', 'C'],\n    'B': ['A', 'D'],\n    'C': ['A', 'D'],\n    'D': ['B', 'C']\n}\n\nprint(grafo)",
        "test_code": "assert \"{'A': ['B', 'C']\" in output and \"'B': ['A', 'D']\" in output and \"'C': ['A', 'D']\" in output and \"'D': ['B', 'C']}\" in output",
        "level": "avançado"
    },
    {
        "id": "ex-grafos-bfs-implementacao-1",
        "lesson_id": "estruturas-algoritmos-avancados-impl",
        "title": "Implementação da Busca em Largura (BFS)",
        "description": "Implemente a função `bfs(grafo, inicio)` que realiza uma Busca em Largura (BFS) em um grafo representado por lista de adjacência, começando por um nó `inicio`. A função deve imprimir os nós visitados na ordem em que são explorados.",
        "difficulty": "Difícil",
        "order": 6,
        "instructions": "Use a representação de grafo do exercício anterior. Importe `collections.deque`. Crie uma fila e adicione o nó inicial. Crie um conjunto para manter os nós visitados e adicione o nó inicial. Enquanto a fila não estiver vazia, retire um nó, imprima-o, e adicione seus vizinhos não visitados à fila e ao conjunto de visitados.",
        "initial_code": "from collections import deque\n\n# Grafo de exemplo (lista de adjacência)\ngrafo = {\n    'A': ['B', 'C'],\n    'B': ['A', 'D', 'E'],\n    'C': ['A', 'F'],\n    'D': ['B'],\n    'E': ['B', 'F'],\n    'F': ['C', 'E']\n}\n\ndef bfs(grafo, inicio):\n    # Implemente a Busca em Largura (BFS) aqui\n    # Use uma fila (deque) e um conjunto de visitados\n    pass\n\nprint(\"Percurso BFS a partir de 'A':\")\n# bfs(grafo, 'A')",
        "solution_code": "from collections import deque\n\n# Grafo de exemplo (lista de adjacência)\ngrafo = {\n    'A': ['B', 'C'],\n    'B': ['A', 'D', 'E'],\n    'C': ['A', 'F'],\n    'D': ['B'],\n    'E': ['B', 'F'],\n    'F': ['C', 'E']\n}\n\ndef bfs(grafo, inicio):\n    visitados = set() # Conjunto para armazenar nós visitados\n    fila = deque([inicio]) # Fila para nós a serem visitados\n\n    visitados.add(inicio)\n\n    while fila:\n        vertice = fila.popleft() # Retira o primeiro nó da fila\n        print(vertice, end=' ')\n\n        # Adiciona vizinhos não visitados à fila e marca como visitado\n        for vizinho in grafo.get(vertice, []):\n            if vizinho not in visitados:\n                visitados.add(vizinho)\n                fila.append(vizinho)\n\nprint(\"Percurso BFS a partir de 'A':\")\nbfs(grafo, 'A')\nprint() # Nova linha para limpar a saída",
        "test_code": "assert \"Percurso BFS a partir de 'A':\" in output and \"A B C D E F\" in output.strip()",
        "level": "avançado"
    },
    {
        "id": "ex-grafos-dfs-recursivo-1",
        "lesson_id": "estruturas-algoritmos-avancados-impl",
        "title": "Implementação da Busca em Profundidade (DFS - Recursiva)",
        "description": "Implemente a função recursiva `dfs_recursivo(grafo, vertice, visitados)` que realiza uma Busca em Profundidade (DFS) em um grafo, começando por um `vertice`. A função deve imprimir os nós visitados na ordem em que são explorados. Use um conjunto `visitados` para rastrear os nós já visitados.",
        "difficulty": "Difícil",
        "order": 7,
        "instructions": "Use a representação de grafo do exercício anterior. A função recursiva deve: 1. Marcar o vértice atual como visitado e imprimi-lo. 2. Para cada vizinho do vértice atual, se o vizinho ainda não foi visitado, chamar `dfs_recursivo` para o vizinho. Comece a chamada com um conjunto `visitados` vazio.",
        "initial_code": "# Grafo de exemplo (lista de adjacência)\ngrafo = {\n    'A': ['B', 'C'],\n    'B': ['A', 'D', 'E'],\n    'C': ['A', 'F'],\n    'D': ['B'],\n    'E': ['B', 'F'],\n    'F': ['C', 'E']\n}\n\ndef dfs_recursivo(grafo, vertice, visitados):\n    # Implemente a Busca em Profundidade (DFS - Recursiva) aqui\n    pass\n\nprint(\"Percurso DFS (Recursiva) a partir de 'A':\")\n# visitados_dfs_rec = set()\n# dfs_recursivo(grafo, 'A', visitados_dfs_rec)\n# print()",
        "solution_code": "# Grafo de exemplo (lista de adjacência)\ngrafo = {\n    'A': ['B', 'C'],\n    'B': ['A', 'D', 'E'],\n    'C': ['A', 'F'],\n    'D': ['B'],\n    'E': ['B', 'F'],\n    'F': ['C', 'E']\n}\n\ndef dfs_recursivo(grafo, vertice, visitados):\n    visitados.add(vertice) # Marca o vértice atual como visitado\n    print(vertice, end=' ') # Imprime o vértice\n\n    # Explora vizinhos não visitados\n    for vizinho in grafo.get(vertice, []):\n        if vizinho not in visitados:\n            dfs_recursivo(grafo, vizinho, visitados)\n\nprint(\"Percurso DFS (Recursiva) a partir de 'A':\")\nvisitados_dfs_rec = set()\ndfs_recursivo(grafo, 'A', visitados_dfs_rec)\nprint()",
        "test_code": "assert \"Percurso DFS (Recursiva) a partir de 'A':\" in output and (\"A B D E F C\" in output.strip() or \"A C F E D B\" in output.strip()) # Ordem pode variar dependendo da ordem dos vizinhos",
        "level": "avançado"
    },
    {
        "id": "ex-grafos-dfs-iterativo-1",
        "lesson_id": "estruturas-algoritmos-avancados-impl",
        "title": "Implementação da Busca em Profundidade (DFS - Iterativa)",
        "description": "Implemente a função iterativa `dfs_iterativo(grafo, inicio)` que realiza uma Busca em Profundidade (DFS) em um grafo, começando por um nó `inicio`. A função deve imprimir os nós visitados na ordem em que são explorados. Use uma pilha (stack) e um conjunto de visitados.",
        "difficulty": "Difícil",
        "order": 8,
        "instructions": "Use a representação de grafo. Use uma lista Python como pilha (`.append()` e `.pop()`). Use um conjunto para visitados. Adicione o nó inicial à pilha e aos visitados. Enquanto a pilha não estiver vazia, retire um nó, imprima-o, e adicione seus vizinhos não visitados à pilha e ao conjunto de visitados. Note que para simular a ordem da recursão, você pode precisar adicionar os vizinhos à pilha em ordem inversa.",
        "initial_code": "# Grafo de exemplo (lista de adjacência)\ngrafo = {\n    'A': ['B', 'C'],\n    'B': ['A', 'D', 'E'],\n    'C': ['A', 'F'],\n    'D': ['B'],\n    'E': ['B', 'F'],\n    'F': ['C', 'E']\n}\n\ndef dfs_iterativo(grafo, inicio):\n    # Implemente a Busca em Profundidade (DFS - Iterativa) aqui\n    # Use uma pilha (lista) e um conjunto de visitados\n    pass\n\nprint(\"Percurso DFS (Iterativa) a partir de 'A':\")\n# dfs_iterativo(grafo, 'A')\n# print()",
        "solution_code": "from collections import deque # Deque pode ser usado como pilha eficiente\n\n# Grafo de exemplo (lista de adjacência)\ngrafo = {\n    'A': ['B', 'C'],\n    'B': ['A', 'D', 'E'],\n    'C': ['A', 'F'],\n    'D': ['B'],\n    'E': ['B', 'F'],\n    'F': ['C', 'E']\n}\n\ndef dfs_iterativo(grafo, inicio):\n    visitados = set() # Conjunto para armazenar nós visitados\n    pilha = [inicio] # Use uma lista como pilha\n\n    visitados.add(inicio)\n    print(inicio, end=' ') # Imprime o nó inicial imediatamente\n\n    while pilha:\n        vertice = pilha[-1] # Espia o topo da pilha\n\n        # Encontra um vizinho não visitado\n        vizinho_nao_visitado = None\n        # Itera sobre vizinhos em ordem inversa para simular a recursão\n        for vizinho in reversed(grafo.get(vertice, [])):\n             if vizinho not in visitados:\n                vizinho_nao_visitado = vizinho\n                break\n\n        if vizinho_nao_visitado:\n            visitados.add(vizinho_nao_visitado)\n            print(vizinho_nao_visitado, end=' ')\n            pilha.append(vizinho_nao_visitado)\n        else:\n            pilha.pop() # Remove o nó do topo se todos os vizinhos foram visitados\n\nprint(\"Percurso DFS (Iterativa) a partir de 'A':\")\ndfs_iterativo(grafo, 'A')\nprint()",
        "test_code": "assert \"Percurso DFS (Iterativa) a partir de 'A':\" in output and (\"A C F E B D\" in output.strip() or \"A B E F C D\" in output.strip()) # Ordem pode variar dependendo da ordem dos vizinhos e implementação da pilha",
        "level": "avançado"
    },
    {
        "id": "ex-flask-forms-data-1",
        "lesson_id": "web-flask-avancado",
        "title": "Manipulando Dados de Formulário POST (Simulado)",
        "description": "Simule como obter dados de um formulário enviado via método POST em uma rota Flask. Assuma que o formulário tem campos 'username' e 'password'. Imprima os valores simulados obtidos.",
        "difficulty": "Médio",
        "order": 1,
        "instructions": "Importe `request` de `flask`. Simule a obtenção dos dados usando `request.form.get('nome_do_campo')`. Imprima os valores obtidos para 'username' e 'password'.",
        "initial_code": "# from flask import request\n\n# Simule os dados do formulário POST (em um ambiente real, viriam do request)\n# class MockRequestForm:\n#     def get(self, key):\n#         data = {'username': 'testuser', 'password': 'securepassword'}\n#         return data.get(key)\n#\n# # Substitua o request real por nosso mock para o teste\n# request.form = MockRequestForm()\n\n# Obtenha os dados simulados do formulário\n# username = request.form.get('username')\n# password = request.form.get('password')\n\n# Imprima os dados obtidos\n# print(f\"Username obtido: {username}\")\n# print(f\"Password obtido: {password}\")\n\nprint(\"Simulação: Configuração para obter dados de formulário POST.\")",
        "solution_code": "from flask import request\n\n# Simule os dados do formulário POST para o teste\nclass MockRequestForm:\n    def get(self, key):\n        data = {'username': 'testuser', 'password': 'securepassword'}\n        return data.get(key)\n\n# Em um ambiente de teste, você pode substituir o request real\n# request.form = MockRequestForm() # Descomentar em um ambiente de teste real\n\n# Para este executor, vamos simular a obtenção diretamente\nusername = 'testuser_simulado'\npassword = 'securepassword_simulado'\n\n# Imprima os dados obtidos\nprint(f\"Username obtido: {username}\")\nprint(f\"Password obtido: {password}\")\n\nprint(\"Simulação: Dados de formulário POST manipulados.\")",
        "test_code": "assert \"Username obtido: testuser_simulado\" in output and \"Password obtido: securepassword_simulado\" in output and \"Simulação: Dados de formulário POST manipulados.\" in output",
        "level": "avançado"
    },
    {
        "id": "ex-flask-forms-validation-1",
        "lesson_id": "web-flask-avancado",
        "title": "Validação Básica de Formulário (Simulado)",
        "description": "Simule a validação básica de um campo de formulário 'email'. Verifique se o campo não está vazio. Se estiver vazio, imprima uma mensagem de erro simulada; caso contrário, imprima uma mensagem de sucesso simulada.",
        "difficulty": "Médio",
        "order": 2,
        "instructions": "Simule a obtenção de um valor para 'email' (primeiro vazio, depois com um valor). Use uma instrução `if` para verificar se o valor é uma string vazia. Imprima as mensagens apropriadas para cada caso.",
        "initial_code": "# Simule o valor do campo 'email' (primeiro vazio)\n# email_simulado_vazio = \"\"\n\n# Verifique se o email está vazio e imprima a mensagem apropriada\n# if not email_simulado_vazio:\n#     print(\"Erro simulado: O campo email não pode estar vazio.\")\n# else:\n#     print(\"Sucesso simulado: Email válido.\")\n\n# Simule o valor do campo 'email' (depois com um valor)\n# email_simulado_valido = \"teste@exemplo.com\"\n\n# Verifique novamente\n# if not email_simulado_valido:\n#     print(\"Erro simulado: O campo email não pode estar vazio.\")\n# else:\n#     print(\"Sucesso simulado: Email válido.\")",
        "solution_code": "# Simula o valor do campo 'email' (primeiro vazio)\nemail_simulado_vazio = \"\"\n\nprint(\"Testando email vazio:\")\n# Verifica se o email está vazio\nif not email_simulado_vazio:\n    print(\"Erro simulado: O campo email não pode estar vazio.\")\nelse:\n    print(\"Sucesso simulado: Email válido.\")\n\n# Simula o valor do campo 'email' (depois com um valor)\nemail_simulado_valido = \"teste@exemplo.com\"\n\nprint(\"\\nTestando email válido:\")\n# Verifica novamente\nif not email_simulado_valido:\n    print(\"Erro simulado: O campo email não pode estar vazio.\")\nelse:\n    print(\"Sucesso simulado: Email válido.\")",
        "test_code": "assert \"Testando email vazio:\" in output and \"Erro simulado: O campo email não pode estar vazio.\" in output and \"Testando email válido:\" in output and \"Sucesso simulado: Email válido.\" in output",
        "level": "avançado"
    },
    {
        "id": "ex-flask-sessions-cookies-conceito-1",
        "lesson_id": "web-flask-avancado",
        "title": "Sessões e Cookies (Conceitual)",
        "description": "Explique a diferença entre Sessões e Cookies em aplicações web Flask e para que cada um é tipicamente usado.",
        "difficulty": "Fácil",
        "order": 3,
        "instructions": "Descreva o que são sessões e cookies, como armazenam informações e seus casos de uso comuns. Use a função print() para sua resposta.",
        "initial_code": "# Explique Sessões e Cookies aqui\n# print(\"Cookies são...\")\n# print(\"Sessões são...\")\n# print(\"Cookies são tipicamente usados para...\")\n# print(\"Sessões são tipicamente usados para...\")",
        "solution_code": "print(\"Cookies são pequenos pedaços de dados que o servidor envia para o navegador do usuário, e o navegador armazena e envia de volta em requisições futuras para o mesmo servidor.\")\nprint(\"Sessões são uma forma de armazenar informações sobre o estado do usuário no servidor entre múltiplas requisições. O navegador geralmente armazena apenas um ID de sessão (em um cookie) que o servidor usa para recuperar os dados da sessão.\")\nprint(\"Cookies são tipicamente usados para lembrar preferências do usuário (idioma, tema), manter o usuário logado (lembrar-me) ou rastreamento.\")\nprint(\"Sessões são tipicamente usadas para armazenar dados sensíveis do usuário (carrinho de compras, status de login) que não devem ser armazenados diretamente no navegador.\")",
        "test_code": "assert \"Cookies são\" in output and \"navegador\" in output.lower() and \"Sessões são\" in output and \"servidor\" in output.lower() and \"ID de sessão\" in output and (\"preferências do usuário\" in output or \"rastreamento\" in output) and (\"dados sensíveis\" in output or \"carrinho de compras\" in output or \"status de login\" in output)",
        "level": "avançado"
    },
    {
        "id": "ex-sqlalchemy-modelo-simples-1",
        "lesson_id": "web-flask-avancado",
        "title": "Definindo um Modelo de Dados com SQLAlchemy (Simulado)",
        "description": "Simule a definição de um modelo SQLAlchemy simples para representar uma tabela `Produto` com colunas `id` (inteiro, chave primária) e `nome` (string, não nulo).",
        "difficulty": "Médio",
        "order": 4,
        "instructions": "Importe `declarative_base` e `Column`, `Integer`, `String` de `sqlalchemy`. Crie a base declarativa. Defina a classe `Produto` herdando da base, com `__tablename__`. Defina as colunas usando `Column()`, especificando os tipos e a chave primária.",
        "initial_code": "# from sqlalchemy import create_engine, Column, Integer, String\n# from sqlalchemy.ext.declarative import declarative_base\n# from sqlalchemy.orm import sessionmaker\n\n# Simule a base declarativa\n# Base = declarative_base()\n\n# Defina o modelo Produto aqui\n# class Produto(Base):\n#     __tablename__ = 'produtos'\n#\n#     id = Column(Integer, primary_key=True)\n#     nome = Column(String, nullable=False)\n#\n#     def __repr__(self):\n#         return f\"<Produto(id={self.id}, nome='{self.nome}')>\"\n\nprint(\"Simulação: Modelo SQLAlchemy 'Produto' definido.\")",
        "solution_code": "from sqlalchemy import create_engine, Column, Integer, String\nfrom sqlalchemy.ext.declarative import declarative_base\n# from sqlalchemy.orm import sessionmaker # Não necessário para a definição do modelo\n\n# Simula a base declarativa\nBase = declarative_base()\n\n# Define o modelo Produto\nclass Produto(Base):\n    __tablename__ = 'produtos'\n\n    id = Column(Integer, primary_key=True)\n    nome = Column(String, nullable=False)\n\n    def __repr__(self):\n        return f\"<Produto(id={self.id}, nome='{self.nome}')>\"\n\nprint(\"Simulação: Modelo SQLAlchemy 'Produto' definido.\")\n# Opcional: Imprimir a representação do modelo (conceitual)\n# print(Produto.__table__)",
        "test_code": "assert \"Simulação: Modelo SQLAlchemy 'Produto' definido.\" in output",
        "level": "avançado"
    },
    {
        "id": "ex-sqlalchemy-crud-create-simulado-1",
        "lesson_id": "web-flask-avancado",
        "title": "CRUD com SQLAlchemy: Criando um Objeto (Simulado)",
        "description": "Simule a criação de um novo objeto `Produto` usando o modelo definido anteriormente e a adição dele a uma sessão SQLAlchemy (simulada).",
        "difficulty": "Médio",
        "order": 5,
        "instructions": "Use o modelo `Produto` (assuma que está definido). Crie uma instância de `Produto` com valores para `nome`. Simule a adição à sessão usando `session.add()`. Imprima uma mensagem confirmando a criação e adição simulada.",
        "initial_code": "# Assuma que o modelo Produto e Base estão definidos (como no exercício anterior)\n# from seu_modulo_de_modelos import Produto, Base # Em um projeto real\n\n# Simule uma sessão SQLAlchemy\n# class MockSession:\n#     def add(self, obj):\n#         print(f\"Simulando: Adicionado objeto à sessão: {obj}\")\n#     def commit(self):\n#         print(\"Simulando: Commit da sessão.\")\n#\n# session = MockSession()\n\n# Crie um novo objeto Produto\n# novo_produto = Produto(nome=\"Teclado\")\n\n# Adicione o objeto à sessão\n# session.add(novo_produto)\n\n# Simule o commit (para persistir no banco)\n# session.commit()\n\nprint(\"Simulação: Criação e adição de objeto Produto à sessão.\")",
        "solution_code": "# Para este exercício, vamos simular a criação e adição sem a infraestrutura completa do SQLAlchemy\n\n# Simula a classe Produto (apenas para que a simulação de adição funcione)\nclass ProdutoSimulado:\n    def __init__(self, nome):\n        self.nome = nome\n    def __repr__(self):\n        return f\"<ProdutoSimulado(nome='{self.nome}')>\"\n\n# Simula uma sessão SQLAlchemy\nclass MockSession:\n    def add(self, obj):\n        print(f\"Simulando: Adicionado objeto à sessão: {obj}\")\n    def commit(self):\n        print(\"Simulando: Commit da sessão.\")\n\nsession = MockSession()\n\n# Crie um novo objeto Produto simulado\nnovo_produto = ProdutoSimulado(nome=\"Mouse Sem Fio\")\n\n# Adicione o objeto à sessão simulada\nsession.add(novo_produto)\n\n# Simule o commit\nsession.commit()\n\nprint(\"Simulação: Criação e adição de objeto Produto à sessão concluída.\")",
        "test_code": "assert \"Simulando: Adicionado objeto à sessão: <ProdutoSimulado(nome='Mouse Sem Fio')>\" in output and \"Simulando: Commit da sessão.\" in output and \"Simulação: Criação e adição de objeto Produto à sessão concluída.\" in output",
        "level": "avançado"
    },
    {
        "id": "ex-sqlalchemy-crud-read-simulado-1",
        "lesson_id": "web-flask-avancado",
        "title": "CRUD com SQLAlchemy: Lendo Objetos (Simulado)",
        "description": "Simule a consulta de objetos `Produto` usando uma sessão SQLAlchemy (simulada). Simule a obtenção de todos os produtos e de um produto por ID.",
        "difficulty": "Médio",
        "order": 6,
        "instructions": "Use o modelo `Produto` (assuma definido). Simule uma sessão com um objeto `query` que tenha métodos `all()` e `get(id)`. Simule a consulta de todos os produtos e de um produto com um ID específico. Imprima os resultados simulados.",
        "initial_code": "# Assuma que o modelo Produto e Base estão definidos\n# from seu_modulo_de_modelos import Produto, Base\n\n# Simule dados no 'banco'\nsimulated_db_data = [\n    {'id': 1, 'nome': 'Teclado'},\n    {'id': 2, 'nome': 'Mouse'},\n    {'id': 3, 'nome': 'Monitor'}\n]\n\n# Simule um objeto Query\n# class MockQuery:\n#     def all(self):\n#         print(\"Simulando: Executando query.all()\")\n#         # Retorne objetos Produto simulados\n#         return [Produto(id=d['id'], nome=d['nome']) for d in simulated_db_data]\n#\n#     def get(self, id):\n#         print(f\"Simulando: Executando query.get({id})\")\n#         # Retorne o objeto Produto simulado com o ID correspondente\n#         for d in simulated_db_data:\n#             if d['id'] == id:\n#                 return Produto(id=d['id'], nome=d['nome'])\n#         return None # Não encontrado\n#\n# # Simule uma sessão com o objeto query\n# class MockSessionWithQuery:\n#      query = MockQuery()\n#\n# session = MockSessionWithQuery()\n\n# Simule a consulta de todos os produtos\n# todos_produtos = session.query.all()\n# print(\"\\nTodos os produtos (simulado):\")\n# print(todos_produtos)\n\n# Simule a consulta de um produto por ID\n# produto_por_id = session.query.get(2)\n# print(\"\\nProduto com ID 2 (simulado):\")\n# print(produto_por_id)\n\nprint(\"Simulação: Configuração para ler objetos Produto com SQLAlchemy.\")",
        "solution_code": "# Para este exercício, vamos simular a consulta sem a infraestrutura completa do SQLAlchemy\n\n# Simula a classe Produto\nclass ProdutoSimulado:\n    def __init__(self, id, nome):\n        self.id = id\n        self.nome = nome\n    def __repr__(self):\n        return f\"<ProdutoSimulado(id={self.id}, nome='{self.nome}')>\"\n\n# Simula dados no 'banco'\nsimulated_db_data = [\n    {'id': 1, 'nome': 'Teclado'},\n    {'id': 2, 'nome': 'Mouse'},\n    {'id': 3, 'nome': 'Monitor'}\n]\n\n# Simula um objeto Query com métodos all() e get()\nclass MockQuery:\n    def all(self):\n        print(\"Simulando: Executando query.all()\")\n        return [ProdutoSimulado(id=d['id'], nome=d['nome']) for d in simulated_db_data]\n\n    def get(self, id):\n        print(f\"Simulando: Executando query.get({id})\")\n        for d in simulated_db_data:\n            if d['id'] == id:\n                return ProdutoSimulado(id=d['id'], nome=d['nome'])\n        return None # Não encontrado\n\n# Simula uma sessão com o objeto query\nclass MockSessionWithQuery:\n     query = MockQuery()\n\nsession = MockSessionWithQuery()\n\n# Simula a consulta de todos os produtos\ntodos_produtos = session.query.all()\nprint(\"\\nTodos os produtos (simulado):\")\nprint(todos_produtos)\n\n# Simula a consulta de um produto por ID\nproduto_por_id = session.query.get(2)\nprint(\"\\nProduto com ID 2 (simulado):\")\nprint(produto_por_id)\n\n# Simula consulta de um produto inexistente\nproduto_inexistente = session.query.get(99)\nprint(\"\\nProduto com ID 99 (simulado):\")\nprint(produto_inexistente)\n\nprint(\"Simulação: Leitura de objetos Produto com SQLAlchemy concluída.\")",
        "test_code": "assert \"Simulando: Executando query.all()\" in output and \"Todos os produtos (simulado):\" in output and \"[<ProdutoSimulado(id=1, nome='Teclado')>, <ProdutoSimulado(id=2, nome='Mouse')>, <ProdutoSimulado(id=3, nome='Monitor')>]\" in output and \"Simulando: Executando query.get(2)\" in output and \"Produto com ID 2 (simulado):\" in output and \"<ProdutoSimulado(id=2, nome='Mouse')>\" in output and \"Simulando: Executando query.get(99)\" in output and \"Produto com ID 99 (simulado):\" in output and \"None\" in output and \"Simulação: Leitura de objetos Produto com SQLAlchemy concluída.\" in output",
        "level": "avançado"
    },
    {
        "id": "ex-flask-blueprints-conceito-1",
        "lesson_id": "web-flask-avancado",
        "title": "Blueprints no Flask (Conceitual)",
        "description": "Explique o que são Blueprints no Flask e qual a sua principal finalidade no desenvolvimento de aplicações maiores.",
        "difficulty": "Fácil",
        "order": 7,
        "instructions": "Descreva o conceito de Blueprint e como ele ajuda a estruturar aplicações Flask. Use a função print() para sua resposta.",
        "initial_code": "# Explique Blueprints aqui\n# print(\"Blueprints no Flask são...\")\n# print(\"Sua principal finalidade é...\")",
        "solution_code": "print(\"Blueprints no Flask são uma forma de organizar um conjunto de rotas, views, templates e outros recursos relacionados em uma estrutura reutilizável e modular.\")\nprint(\"Sua principal finalidade é ajudar a estruturar aplicações Flask maiores em componentes menores e mais gerenciáveis, evitando que toda a lógica e rotas fiquem em um único arquivo e facilitando a criação de aplicativos reutilizáveis.\")",
        "test_code": "assert \"Blueprints no Flask são\" in output and (\"organizar\" in output or \"modular\") and (\"aplicações Flask maiores\" in output or \"componentes menores\" in output or \"estrutura\" in output)",
        "level": "avançado"
    },
    {
        "id": "ex-flask-blueprints-estrutura-simulada-1",
        "lesson_id": "web-flask-avancado",
        "title": "Estrutura Básica de um Blueprint (Simulado)",
        "description": "Simule a estrutura básica de como definir um Blueprint simples no Flask.",
        "difficulty": "Médio",
        "order": 8,
        "instructions": "Importe `Blueprint` de `flask`. Crie uma instância de `Blueprint`, especificando um nome e o `__name__` do módulo. Simule a definição de uma rota usando o decorador do Blueprint (ex: `@meu_bp.route('/')`). Imprima uma mensagem confirmando a simulação.",
        "initial_code": "# from flask import Blueprint\n\n# Simule a criação de um Blueprint\n# meu_bp = Blueprint('meu_blueprint', __name__)\n\n# Simule a definição de uma rota no Blueprint\n# @meu_bp.route('/')\n# def index_bp():\n#     return \"Rota do Blueprint\"\n\nprint(\"Simulação: Estrutura básica de um Blueprint Flask definida.\")",
        "solution_code": "from flask import Blueprint\n\n# Simula a criação de um Blueprint\n# meu_bp = Blueprint('meu_blueprint', __name__)\n\n# Simula a definição de uma rota no Blueprint\n# @meu_bp.route('/')\n# def index_bp():\n#     return \"Rota do Blueprint\"\n\nprint(\"Simulação: Estrutura básica de um Blueprint Flask definida.\")",
        "test_code": "assert \"Simulação: Estrutura básica de um Blueprint Flask definida.\" in output",
        "level": "avançado"
    },
    {
        "id": "ex-flask-testing-simples-1",
        "lesson_id": "web-flask-avancado",
        "title": "Escrevendo um Teste Básico para Rota Flask (Simulado)",
        "description": "Simule a escrita de um teste básico para uma rota Flask `/` que retorna \"Olá, Mundo!\". O teste deve verificar se a resposta da rota é a esperada e se o status code é 200.",
        "difficulty": "Médio",
        "order": 9,
        "instructions": "Assuma que você tem uma instância `app` do Flask. Crie um cliente de teste usando `app.test_client()`. Use o cliente para fazer uma requisição GET para `/`. Verifique a resposta (`response.data`) e o status code (`response.status_code`) usando `assert`. Imprima mensagens indicando o que está sendo testado e se o teste passou (simulado).",
        "initial_code": "# from flask import Flask\n# import pytest # Assume que pytest seria usado em um ambiente real\n\n# Simule uma aplicação Flask mínima para teste\n# app = Flask(__name__)\n# @app.route('/')\n# def index():\n#     return \"Olá, Mundo!\"\n\n# Simule a escrita do teste\n# def test_index_route():\n#     # Crie um cliente de teste\n#     client = app.test_client()\n#\n#     # Faça uma requisição GET para a rota raiz\n#     response = client.get('/')\n#\n#     # Verifique a resposta e o status code\n#     assert response.data.decode('utf-8') == \"Olá, Mundo!\"\n#     assert response.status_code == 200\n#\n#     print(\"Simulação: Teste da rota '/' passou (resposta e status code corretos).\")\n\n# Simule a execução do teste\n# test_index_route()\nprint(\"Simulação: Configuração para testar rotas Flask.\")",
        "solution_code": "# Para este exercício, vamos simular a lógica do teste sem a execução real do Flask\n\n# Simula a resposta de uma requisição GET para a rota '/'\nclass MockResponse:\n    def __init__(self, data, status_code):\n        self.data = data.encode('utf-8') # Dados em bytes\n        self.status_code = status_code\n\n# Simula a escrita do teste\ndef test_index_route_simulado():\n    print(\"Simulação: Executando teste para a rota '/'.\")\n    # Simula a resposta esperada\n    response_simulada = MockResponse(\"Olá, Mundo!\", 200)\n\n    # Verifique a resposta e o status code\n    assert response_simulada.data.decode('utf-8') == \"Olá, Mundo!\"\n    assert response_simulada.status_code == 200\n\n    print(\"Simulação: Teste da rota '/' passou (resposta e status code corretos).\")\n\n# Simule a execução do teste\ntest_index_route_simulado()\n\nprint(\"Simulação: Teste básico para rota Flask concluído.\")",
        "test_code": "assert \"Simulação: Executando teste para a rota '/'.\" in output and \"Simulação: Teste da rota '/' passou (resposta e status code corretos).\" in output and \"Simulação: Teste básico para rota Flask concluído.\" in output",
        "level": "avançado"
    },
    {
        "id": "ex-django-intro-conceito-1",
        "lesson_id": "web-django-intro",
        "title": "Framework Full-stack (Django) vs Microframework (Flask) (Conceitual)",
        "description": "Explique o que diferencia um framework web 'full-stack' como o Django de um 'microframework' como o Flask. Mencione a principal vantagem de usar um framework full-stack.",
        "difficulty": "Fácil",
        "order": 1,
        "instructions": "Descreva a diferença entre os dois tipos de frameworks e a vantagem do full-stack. Use a função print() para sua resposta.",
        "initial_code": "# Explique a diferença entre full-stack e microframework, e a vantagem do full-stack aqui\n# print(\"Um framework full-stack como o Django...\")\n# print(\"Um microframework como o Flask...\")\n# print(\"A principal vantagem de um full-stack é...\")",
        "solution_code": "print(\"Um framework full-stack como o Django oferece a maioria dos componentes necessários para construir uma aplicação web completa 'de ponta a ponta', incluindo ORM, sistema de templates, sistema de administração, etc.\")\nprint(\"Um microframework como o Flask fornece apenas o núcleo essencial (roteamento, requisição/resposta), deixando a escolha de componentes adicionais (banco de dados, formulários, etc.) para o desenvolvedor.\")\nprint(\"A principal vantagem de um full-stack é a agilidade inicial, pois muitos componentes já vêm integrados, reduzindo a necessidade de escolher e configurar bibliotecas separadas.\")",
        "test_code": "assert \"full-stack\" in output.lower() and \"microframework\" in output.lower() and \"Django\" in output and \"Flask\" in output and (\"componentes\" in output or \"integrados\" in output or \"agilidade\" in output)",
        "level": "avançado"
    },
    {
        "id": "ex-django-instalacao-1",
        "lesson_id": "web-django-intro",
        "title": "Instalação do Django (Simulado)",
        "description": "Qual comando você usaria no terminal para instalar o Django usando o pip?",
        "difficulty": "Fácil",
        "order": 2,
        "instructions": "Imprima a linha de comando exata para instalar o Django via pip.",
        "initial_code": "# Imprima o comando de instalação do Django aqui\n# print(\"...\")",
        "solution_code": "print(\"pip install Django\")",
        "test_code": "assert output.strip() == \"pip install Django\"",
        "level": "avançado"
    },
    {
        "id": "ex-django-projeto-app-simulado-1",
        "lesson_id": "web-django-intro",
        "title": "Criando Projeto e App Django (Simulado)",
        "description": "Simule os comandos que você executaria no terminal para criar um novo projeto Django chamado `meuprojeto` e, em seguida, um app dentro dele chamado `meuapp`.",
        "difficulty": "Fácil",
        "order": 3,
        "instructions": "Imprima os dois comandos `django-admin startproject` e `python manage.py startapp` com os nomes especificados.",
        "initial_code": "# Simule os comandos para criar projeto e app Django aqui\n# print(\"...\")\n# print(\"...\")",
        "solution_code": "print(\"django-admin startproject meuprojeto\")\nprint(\"cd meuprojeto\")\nprint(\"python manage.py startapp meuapp\")",
        "test_code": "assert \"django-admin startproject meuprojeto\" in output and \"cd meuprojeto\" in output and \"python manage.py startapp meuapp\" in output",
        "level": "avançado"
    },
    {
        "id": "ex-django-estrutura-conceito-1",
        "lesson_id": "web-django-intro",
        "title": "Estrutura Básica de Projeto/App Django (Conceitual)",
        "description": "Mencione os principais arquivos ou diretórios que são criados por padrão ao criar um projeto Django (`manage.py`, diretório do projeto) e um app Django (`models.py`, `views.py`, `urls.py`, `admin.py`).",
        "difficulty": "Fácil",
        "order": 4,
        "instructions": "Liste os principais componentes de um projeto e um app Django. Use a função print() para sua resposta.",
        "initial_code": "# Liste os principais arquivos/diretórios de um projeto/app Django aqui\n# print(\"Projeto Django: ...\")\n# print(\"App Django: ...\")",
        "solution_code": "print(\"Principais componentes de um Projeto Django: manage.py (utilitário de linha de comando), diretório do projeto (com settings.py, urls.py principal, wsgi.py, asgi.py).\")\nprint(\"Principais componentes de um App Django: models.py (modelos de dados), views.py (lógica das requisições), urls.py (mapeamento de URLs), admin.py (configuração do site admin), apps.py (configuração do app), migrations/ (histórico de migrações).\")",
        "test_code": "assert \"Projeto Django:\" in output and \"manage.py\" in output and \"settings.py\" in output and \"App Django:\" in output and \"models.py\" in output and \"views.py\" in output and \"urls.py\" in output and \"admin.py\" in output",
        "level": "avançado"
    },
    {
        "id": "ex-django-models-simples-1",
        "lesson_id": "web-django-intro",
        "title": "Definindo um Modelo Django Simples",
        "description": "Defina um modelo Django chamado `Post` com dois campos: `titulo` (CharField, max_length=100) e `conteudo` (TextField).",
        "difficulty": "Médio",
        "order": 5,
        "instructions": "Importe `models` de `django.db`. Crie a classe `Post` herdando de `models.Model`. Defina os campos `titulo` e `conteudo` com os tipos e opções apropriados.",
        "initial_code": "# from django.db import models\n\n# Defina o modelo Post aqui\n# class Post(models.Model):\n#     titulo = ...\n#     conteudo = ...\n\n#     def __str__(self):\n#         return self.titulo\n\nprint(\"Simulação: Modelo Django 'Post' definido.\")",
        "solution_code": "print(\"from django.db import models\\n\\nclass Post(models.Model):\\n    titulo = models.CharField(max_length=100)\\n    conteudo = models.TextField()\\n\\n    def __str__(self):\\n        return self.titulo\")",
        "test_code": "assert \"from django.db import models\" in output and \"class Post(models.Model):\" in output and \"titulo = models.CharField(max_length=100)\" in output",
        "level": "avançado"
    },
    {
        "id": "ex-django-migrations-simulado-1",
        "lesson_id": "web-django-intro",
        "title": "Criando e Aplicando Migrações (Simulado)",
        "description": "Simule os comandos que você executaria no terminal para criar as migrações para um app Django (`meuapp`) após definir ou modificar modelos, e depois aplicar essas migrações ao banco de dados.",
        "difficulty": "Fácil",
        "order": 6,
        "instructions": "Imprima os dois comandos `python manage.py makemigrations` (especificando o app, opcional mas boa prática) e `python manage.py migrate`.",
        "initial_code": "# Simule os comandos para criar e aplicar migrações Django aqui\n# print(\"...\")\n# print(\"...\")",
        "solution_code": "print(\"python manage.py makemigrations meuapp\")\nprint(\"python manage.py migrate\")",
        "test_code": "assert \"python manage.py makemigrations meuapp\" in output and \"python manage.py migrate\" in output",
        "level": "avançado"
    },
    {
        "id": "ex-django-shell-orm-simulado-1",
        "lesson_id": "web-django-intro",
        "title": "Interagindo com o ORM no Shell (Simulado)",
        "description": "Simule os comandos Python que você executaria no shell interativo do Django (`python manage.py shell`) para importar o modelo `Post` e criar uma nova instância dele.",
        "difficulty": "Médio",
        "order": 7,
        "instructions": "Simule a importação do modelo (`from meuapp.models import Post`). Simule a criação de uma instância (`novo_post = Post(...)`). Imprima as linhas de código simuladas.",
        "initial_code": "# Simule os comandos do shell Django aqui\n# print(\">>> from meuapp.models import Post\")\n# print(\">>> novo_post = Post(titulo='Meu Primeiro Post', conteudo='Conteúdo do post.')\")\n# print(\">>> novo_post.save() # Para salvar no banco\")",
        "solution_code": "print(\">>> from meuapp.models import Post\")\nprint(\">>> novo_post = Post(titulo='Meu Primeiro Post', conteudo='Conteúdo do post.')\")\nprint(\">>> print(novo_post.titulo) # Acessando um atributo\")\nprint(\">>> # Para salvar no banco: novo_post.save()\")",
        "test_code": "assert \">>> from meuapp.models import Post\" in output and \">>> novo_post = Post(titulo='Meu Primeiro Post', conteudo='Conteúdo do post.')\" in output and \">>> print(novo_post.titulo) # Acessando um atributo\" in output",
        "level": "avançado"
    },
    {
        "id": "ex-django-admin-registro-simulado-1",
        "lesson_id": "web-django-intro",
        "title": "Registrando Modelo no Site Admin (Simulado)",
        "description": "Simule o código Python que você adicionaria ao arquivo `admin.py` de um app Django (`meuapp`) para registrar o modelo `Post` e torná-lo visível e gerenciável no site administrativo do Django.",
        "difficulty": "Fácil",
        "order": 8,
        "instructions": "Importe `admin` de `django.contrib`. Importe o modelo `Post` do seu app. Use `admin.site.register()` para registrar o modelo. Imprima as linhas de código simuladas.",
        "initial_code": "# Simule o código para meuapp/admin.py aqui\n# print(\"# meuapp/admin.py\")\n# print(\"# from django.contrib import admin\")\n# print(\"# from .models import Post\")\n# print(\"#\")\n# print(\"# admin.site.register(Post)\")",
        "solution_code": "print(\"# meuapp/admin.py\")\nprint(\"from django.contrib import admin\")\nprint(\"from .models import Post\")\nprint(\"\")\nprint(\"admin.site.register(Post)\")",
        "test_code": "assert \"# meuapp/admin.py\" in output and \"from django.contrib import admin\" in output and \"from .models import Post\" in output and \"admin.site.register(Post)\" in output",
        "level": "avançado"
    },
    {
        "id": "ex-django-urls-simples-1",
        "lesson_id": "web-django-intro",
        "title": "Definindo uma URL Simples (Simulado)",
        "description": "Simule a definição de um padrão de URL simples no arquivo `urls.py` de um app Django (`meuapp`) que mapeia o caminho '' (raiz do app) para uma view function chamada `index`.",
        "difficulty": "Médio",
        "order": 9,
        "instructions": "Importe `path` de `django.urls`. Importe as views do seu app (`from . import views`). Defina a lista `urlpatterns`. Adicione um objeto `path` mapeando o caminho vazio para `views.index` e dê um nome ('index'). Imprima as linhas de código simuladas.",
        "initial_code": "# Simule o código para meuapp/urls.py aqui\n# print(\"# meuapp/urls.py\")\n# print(\"# from django.urls import path\")\n# print(\"# from . import views\")\n# print(\"#\")\n# print(\"# urlpatterns = [\"])\n# print(\"#     path('', views.index, name='index'),\")\n# print(\"# ]\")",
        "solution_code": "print(\"# meuapp/urls.py\")\nprint(\"from django.urls import path\")\nprint(\"from . import views\")\nprint(\"\")\nprint(\"urlpatterns = [\")\nprint(\"    path('', views.index, name='index'),\")\nprint(\"]\")",
        "test_code": "assert \"# meuapp/urls.py\" in output and \"from django.urls import path\" in output and \"from . import views\" in output and \"urlpatterns = [\" in output and \"path('', views.index, name='index'),\" in output and \"]\" in output",
        "level": "avançado"
    },
    {
        "id": "ex-django-views-simples-1",
        "lesson_id": "web-django-intro",
        "title": "Criando uma View Function Simples (Simulado)",
        "description": "Simule a criação de uma view function simples chamada `index` no arquivo `views.py` de um app Django (`meuapp`) que retorna uma resposta HTTP simples com o texto \"Olá do Django!\".",
        "difficulty": "Médio",
        "order": 10,
        "instructions": "Importe `HttpResponse` de `django.http`. Defina a função `index` que aceita `request` como parâmetro. Retorne uma instância de `HttpResponse` com o texto desejado. Imprima as linhas de código simuladas.",
        "initial_code": "# Simule o código para meuapp/views.py aqui\n# print(\"# meuapp/views.py\")\n# print(\"# from django.shortcuts import render\") # Pode ser necessário depois\n# print(\"# from django.http import HttpResponse\")\n# print(\"#\")\n# print(\"# def index(request):\")\n# print(\"#     return HttpResponse(\\\"Olá do Django!\\\")\")",
        "solution_code": "print(\"# meuapp/views.py\")\nprint(\"from django.http import HttpResponse\")\nprint(\"\")\nprint(\"def index(request):\")\nprint(\"    return HttpResponse(\\\"Olá do Django!\\\")\")",
        "test_code": "assert \"# meuapp/views.py\" in output and \"from django.http import HttpResponse\" in output and \"def index(request):\" in output and \"return HttpResponse(\\\"Olá do Django!\\\")\" in output",
        "level": "avançado"
    },
    {
        "id": "ex-poo-property-1",
        "lesson_id": "poo-avancado-patterns-parte2",
        "title": "Usando @property para Atributo Gerenciado",
        "description": "Crie uma classe `Temperatura` que armazena a temperatura em Celsius. Use `@property` para criar um atributo `fahrenheit` que converte e retorna a temperatura em Fahrenheit (F = C * 9/5 + 32).",
        "difficulty": "Médio",
        "order": 1,
        "instructions": "O construtor deve receber a temperatura em Celsius e armazená-la em um atributo 'privado' (ex: `_celsius`). O método `fahrenheit` decorado com `@property` deve realizar o cálculo e retornar o valor.",
        "initial_code": "class Temperatura:\n    def __init__(self, celsius):\n        self._celsius = celsius\n\n    # Defina a property 'fahrenheit' aqui\n    # @property\n    # def fahrenheit(self):\n    #     # Calcule e retorne F = self._celsius * 9/5 + 32\n    #     pass\n\n# temp_c = Temperatura(25)\n# print(f\"Celsius: {temp_c._celsius}\")\n# print(f\"Fahrenheit: {temp_c.fahrenheit}\") # Acessado como um atributo",
        "solution_code": "class Temperatura:\n    def __init__(self, celsius):\n        self._celsius = celsius\n\n    @property\n    def celsius(self):\n        return self._celsius\n\n    @celsius.setter\n    def celsius(self, valor):\n        self._celsius = valor\n\n    @property\n    def fahrenheit(self):\n        return self._celsius * 9/5 + 32\n\ntemp_c = Temperatura(25)\nprint(f\"Celsius: {temp_c.celsius}\")\nprint(f\"Fahrenheit: {temp_c.fahrenheit}\")\n\ntemp_c.celsius = 0\nprint(f\"Novo Celsius: {temp_c.celsius}\")\nprint(f\"Novo Fahrenheit: {temp_c.fahrenheit}\")",
        "test_code": "assert \"Fahrenheit: 77.0\" in output and \"Novo Fahrenheit: 32.0\" in output",
        "level": "avançado"
        
    },
    {
        "id": "ex-algoritmos-heap-sort-conceito-1",
        "lesson_id": "estruturas-algoritmos-avancados-ordenacao-grafos",
        "title": "Conceito de Heap Sort (Extração)",
        "description": "Descreva em uma frase o que acontece na fase de 'extração de elementos' do algoritmo Heap Sort, após o Max Heap ter sido construído.",
        "difficulty": "Fácil",
        "order": 1,
        "instructions": "Pense em como o maior elemento é usado e como o heap é mantido. Imprima sua resposta.",
        "initial_code": "# print(\"Na fase de extração do Heap Sort, ...\")",
        "solution_code": "print(\"Na fase de extração do Heap Sort, o maior elemento (raiz do Max Heap) é trocado com o último elemento da porção não ordenada da lista, e o heap é reconstruído com os elementos restantes para encontrar o próximo maior.\")",
        "test_code": "assert \"maior elemento\" in output.lower() and \"trocado com o último\" in output.lower() and \"heap é reconstruído\" in output.lower()",
        "level": "avançado"
        
    },
    {
        "id": "ex-django-forms-csrf-1",
        "lesson_id": "web-django-forms-security",
        "title": "Tag CSRF Token em Template Django",
        "description": "Qual tag de template Django é usada para incluir o token CSRF em um formulário HTML para proteção contra Cross-Site Request Forgery? Imprima a tag completa.",
        "difficulty": "Fácil",
        "order": 1,
        "instructions": "Lembre-se da sintaxe das tags de template Django.",
        "initial_code": "# Imprima a tag CSRF token aqui\n# print(\"{% ... %}\")",
        "solution_code": "print(\"{% csrf_token %}\")",
        "test_code": "assert output.strip() == \"{% csrf_token %}\"",
        "level": "avançado"
        
    },
    {
        "id": "projeto-final-avancado-completo",
        "lesson_id": "projeto-final-curso-avancado",
        "title": "Projeto Final: Sistema de Análise e Visualização de Dados com API e Persistência",
        "description": "<p>Este projeto final tem como objetivo consolidar e aplicar os conhecimentos avançados adquiridos no curso, integrando diversos tópicos como POO, Design Patterns, manipulação de arquivos, requisições web, bancos de dados, concorrência e testes. Você desenvolverá uma aplicação que simula a coleta, análise, visualização e disponibilização de dados.</p><h3>Objetivo Geral:</h3><p>Desenvolver uma aplicação Python que colete dados de uma fonte externa (simulada ou real via API), processe/analise esses dados, persista-os em um banco de dados, permita a consulta via uma API RESTful própria e gere visualizações.</p><h3>Requisitos Detalhados:</h3><ol><li><strong>Estrutura do Projeto:</strong> Organize o código em módulos e pacotes Python bem definidos (usando Blueprints se for web, ou estrutura similar para CLI/API). Utilize um ambiente virtual para gerenciar as dependências.</li><li><strong>Programação Orientada a Objetos (POO):</strong> Modele as entidades principais do seu sistema (ex: Dados, FonteDados, Analisador, BancoDados, API) utilizando classes com atributos e métodos apropriados.</li><li><strong>Design Patterns:</strong> Aplique pelo menos dois Design Patterns estudados (ex: Factory Method para criar diferentes tipos de fontes de dados, Observer para notificar sobre novos dados, Singleton para uma configuração global, Facade para simplificar a interação com o banco de dados).</li><li><strong>Metaclasses, Decorators e Geradores:</strong><br><ul><li>Utilize um decorador de função (com ou sem argumentos) para adicionar funcionalidade a métodos (ex: log de execução, validação de entrada).</li><li>Considere o uso de geradores para processar grandes volumes de dados de forma eficiente (ex: ler um arquivo grande linha por linha, processar stream de dados).</li><li>(Opcional/Avançado) Explore o uso de metaclasses para tarefas como registro automático de classes ou validação na definição de classes, se aplicável ao seu design.</li></ul></li><li><strong>Manipulação de Arquivos e Dados:</strong><br><ul><li>Implemente a leitura de dados de um arquivo (CSV ou JSON) como uma das fontes de dados (simulada ou real).</li><li>Realize operações de manipulação e limpeza básica dos dados lidos (usando Pandas, se desejar, embora não seja estritamente obrigatório focar em Pandas avançado aqui, a manipulação de dados é o ponto).</li></ul></li><li><strong>Requisições Web e APIs:</strong><br><ul><li>Utilize a biblioteca <code>requests</code> para simular a coleta de dados de uma API externa (pode ser uma API pública simples ou uma URL que retorna um JSON/CSV estático).</li><li>(Opcional/Avançado) Desenvolva uma pequena API RESTful própria (usando Flask ou Django) para expor os dados processados ou permitir a interação com o sistema.</li></ul></li><li><strong>Banco de Dados:</strong><br><ul><li>Utilize um banco de dados relacional (SQLite é suficiente para um projeto local) com uma biblioteca ORM (SQLAlchemy ou o ORM do Django, se usar Django).</li><li>Defina modelos de dados que representem a estrutura dos dados que você está coletando/processando.</li><li>Implemente operações CRUD (Criar, Ler, Atualizar, Deletar) para persistir e recuperar dados do banco.</li></ul></li><li><strong>Concorrência e Paralelismo:</strong><br><ul><li>Identifique uma parte do seu sistema onde a concorrência ou paralelismo pode melhorar o desempenho (ex: coletar dados de múltiplas fontes simultaneamente, processar dados em paralelo).</li><li>Implemente a solução usando <code>threading</code> (para tarefas I/O-bound como requisições web) ou <code>multiprocessing</code> (para tarefas CPU-bound como processamento pesado de dados).</li></ul></li><li><strong>Testes Unitários:</strong> Escreva testes unitários (usando <code>unittest</code> ou <code>pytest</code>) para as partes críticas do seu código (ex: funções de processamento de dados, métodos de classes, lógica de acesso ao banco de dados).</li><li><strong>Documentação:</strong> Inclua comentários no código e, opcionalmente, crie uma documentação básica do projeto (README.md explicando como configurar e executar).</li></ol><h3>Sugestões de Tema (opcional, sinta-se à vontade para adaptar):</h3><ul><li>Análise de dados de vendas de uma loja.</li><li>Monitoramento simulado de status de servidores.</li><li>Coleta e análise de dados de redes sociais (simulado).</li><li>Sistema simples de gestão de inventário com persistência.</li></ul><h3>Entrega:</h3><p>O projeto completo deve ser desenvolvido em seu ambiente local. A entrega consistirá no código-fonte organizado em um repositório Git (GitHub, GitLab, etc.) e, opcionalmente, um pequeno relatório ou apresentação explicando o design, as escolhas técnicas (Design Patterns, concorrência, etc.) e como executar a aplicação.</p><h3>Instruções para este Exercício no Ambiente do Curso:</h3><p>Para este exercício específico, você deve apenas imprimir uma mensagem confirmando que compreendeu os requisitos do projeto e está pronto para iniciar o desenvolvimento em seu ambiente local.</p>",
        "difficulty": "Projeto",
        "order": 1,
        "instructions": "Leia atentamente a descrição e os requisitos do projeto final. Este exercício serve como ponto de partida. O desenvolvimento real será feito fora deste ambiente. Imprima a mensagem de confirmação abaixo para marcar este exercício como 'iniciado'.",
        "initial_code": "# Projeto Final: Sistema de Análise e Visualização de Dados\n\n# Leia a descrição e os requisitos detalhados acima.\n# Este exercício é o ponto de partida para desenvolver o projeto completo\n# em seu ambiente local.\n\n# Após compreender os requisitos, imprima a mensagem abaixo para confirmar.\n\nprint(\"Compreendi os requisitos do Projeto Final e estou pronto para iniciar o desenvolvimento!\")",
        "solution_code": "print(\"# A solução para este exercício é o projeto completo desenvolvido pelo aluno,\n# seguindo todos os requisitos detalhados nas instruções.\n# O projeto deve ser entregue em um repositório Git conforme especificado.\")",
        "test_code": "assert \"Compreendi os requisitos do Projeto Final e estou pronto para iniciar o desenvolvimento!\" in output.strip(), \"Certifique-se de imprimir a mensagem de confirmação correta após ler os requisitos do projeto.\"",
        "level":"avançado"
    }
]